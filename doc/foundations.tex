% copyright (c) 2015 Synrc Research Center

\documentclass[11pt,oneside]{article}

\input{synrc.tex}
\begin{document}

\thispagestyle{empty}
\begin{center}

\begin{minipage}[t]{2cm}
    \includegraphics[scale=0.4]{img/S}
\end{minipage}
\begin{minipage}[t]{12cm}
    \begin{flushright}
        \textsc{{\Large {\bf {\color{Blue}syn}{\color{OrangeRed}rc} research center s.r.o.}}}\\
        \textsc{Roháčova 141/18, Praha 3 13000, Czech Republic}\\
    \end{flushright}
\end{minipage}

\vspace{3cm}

    \vspace{3cm}   {\Large \bf Foundations of Lambek Encoding\\}\par
    \vspace{0.3cm} {\Large Technical Article\par}
    \vspace{0.3cm} {\Large Maxim Sokhatsky, Synrc Research Center\par}
    \vspace{4cm}   {\Large Kyiv 2016}

\end{center}

\newpage
\vspace{2cm}
\tableofcontents
\newpage

\section{Category Theory}
\vspace{0.3cm}

   \subsection{Programs and Functions}
   Category theory is widely used as an instrument for mathematicians for software analisys.
   Category theory could be treated as an abstract algebra of functions. Let's define an Category
   formally: {\bf Category} consists of two lists: the one is morphisms (arrows) and the second is
   objects (domains and codomains of arrows) along with assoociative operation of composition and
   unit morphism that exists for all objects in category.

   \paragraph{}
   The formation axoims of objects and arrows are not given here and autopostulating yet. Formation axoims
   will be introduced during exponential definition. Objects $A$ and $B$ of an arrow $f: A \rightarrow B$
   are called {\bf domain} and {\bf codomain} respectively.

   \paragraph{}
   Intro axioms -- associativity of composition and left/right unit arrow compisitions show that
   categories are actually typed monoids, which consist of morphisms and operation of composition.
   There are many languages to show the semantic of categories such as commutative diagrams and string diagrams
   however here we define here in proof-theoretic manner:

\begingroup
\parbox[t][][l]{0.60\textwidth}{

\begin{prooftree}
\AxiomC{$\Gamma\ \vdash f: A \rightarrow B$ }
\AxiomC{$\Gamma\ \vdash g: B \rightarrow C$ }
\BinaryInfC{$\Gamma \vdash g \circ f : A \rightarrow C $}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash f : B \rightarrow A$ }
\AxiomC{$\Gamma \vdash g : C \rightarrow B$ }
\AxiomC{$\Gamma \vdash h : D \rightarrow C$ }
\TrinaryInfC{$\Gamma \vdash (f \circ g) \circ h = f \circ (g \circ h) : D \rightarrow A $}
\end{prooftree}

}
\hspace{0.1cm}
\parbox[t][][r]{0.40\textwidth}{

\begin{prooftree}
\AxiomC{$$ }
\UnaryInfC{$\Gamma \vdash id_A : A \rightarrow A $}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma\ \vdash f: A \rightarrow B$ }
\UnaryInfC{$\Gamma \vdash f \circ id_A = f : A \rightarrow B$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma\ \vdash f: A \rightarrow B$ }
\UnaryInfC{$\Gamma \vdash id_B \circ f = f : A \rightarrow B $}
\end{prooftree}

}
\endgroup

\paragraph{}
Composition shows an ability to connect the result space of the previous evaluation (codomain)
and the arguments space of the next evaluation (domain). Composition is fundamental property of morphisms
that allows us to chain evaluations.

\paragraph{}
\begin{tabular}{lll}
$1.$ & $A: *$\\
$2.$ & $A: *\ ,\ B: * \implies f: A \rightarrow B$\\
$3.$ & $f: B \rightarrow C\ ,\ g: A \rightarrow B \implies f \circ g : A \rightarrow C$\\
$4.$ & $(f \circ g) \circ h = f \circ (g \circ h)$\\
$5.$ & $A \implies id : A \rightarrow A$\\
$6.$ & $f \circ id = f$\\
$7.$ & $id \circ f = f$\\
\end{tabular}

\newpage
\subsection{Algebraic Types and Cartesian Categories}

After composition operation of construction of new objects with morphisms we introduce
operation of construction cartesian product of two objects $A$ and $B$ of a given
category along with morphism product $<f,g>$ with a common domain, that is needed
for full definition of cartesian product of $A \times B$.

\paragraph{}
This is an internal language of cartesian category, in which for all two selected objects there is an object
of cartesian product (sum) of two objects along with its $\bot$ terminal (or $\top$ coterminal) type.
Exe languages is always equiped with product and sum types.

\paragraph{}
Product has two eliminators $\pi$ with an common domain, which are also called projections of an product.
The sum has eliminators $i$ with an common codomain.
Note that eliminators $\pi$ and $i$ are isomorphic, that is $\pi \circ \sigma = \sigma \circ \pi = id$.

\begingroup
\parbox[t][][l]{0.40\textwidth}{

\begin{prooftree}
\AxiomC{$\Gamma\ x: A \times B$ }
\UnaryInfC{$\Gamma \vdash \pi_1\ : A \times B \rightarrow A$;
           $\Gamma \vdash \pi_2\ : A \times B \rightarrow B$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash\  a:A$ }
\AxiomC{$\Gamma \vdash\  b:B$ }
\BinaryInfC{$\Gamma \vdash\ (a,b) : A \times B$ }
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash\ \top$ }
\end{prooftree}

}
\hspace{0.1cm}
\parbox[t][][r]{0.60\textwidth}{

\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash\ \bot$ }
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash\  a:A$ }
\AxiomC{$\Gamma \vdash\  b:B$ }
\BinaryInfC{$\Gamma\vdash a\ |\ b : A \otimes B$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma\ x: A \otimes B$ }
\UnaryInfC{$\Gamma \vdash \i_1: A \rightarrow A \otimes B$;
           $\Gamma \vdash \i_2: B \rightarrow A \otimes B$}
\end{prooftree}

}
\endgroup

   \paragraph{}

   The $\bot$ type in Haskell is used as {\bf undefined} type (empty sum component presented in all types), that
   is why Hask category is not based on cartesian closed but CPO\cite{cpo}. The $\bot$ type has no values.
   The $\top$ type is known as unit type or zero tuple $()$ often
   used as an default argument for function with zero arguments.
   Also we include here an axiom of morphism product which is given during full definition
   of product using commutative diagram. This axiom is needed for applicative
   programming in categorical abstract machine. Also consider co-version of this
   axiom for $[f,g]: B+C \rightarrow A$ morphism sums.

\begin{prooftree}
\AxiomC{$\Gamma \vdash\ f:A \rightarrow B$ }
\AxiomC{$\Gamma \vdash\ g:A \rightarrow C$ }
\AxiomC{$\Gamma \vdash\ B \times C$ }
\TrinaryInfC{$\Gamma \vdash\ \langle f,g \rangle : A \rightarrow B \times C$ }
\end{prooftree}

\begin{center}
%$(f \circ g) \circ h = f \circ (g \circ h)$\\
%$f \circ id = f$\\
%$id \circ f = f$\\
$\pi_1 \circ \langle f, g \rangle = f$\\
$\pi_2 \circ \langle f, g \rangle = g$\\
$\langle f \circ \pi_1, f \circ \pi_2 \rangle = f$\\
$\langle f, g \rangle \circ h = \langle f \circ h, g \circ h \rangle$\\
$\langle \pi_1, \pi_2 \rangle = id$\\
\end{center}

\newpage
   \subsection{Exponential, $\lambda$-calculus and Cartesian Closed Categories}
   Being an internal language of cartesian closed category, lambda calculus except variables and constants
   provides two operations of abstraction and applications which defines complete evaluation language
   with higher order functions, recursion and corecursion, etc.

   \paragraph{}
   To explain functions from the categorical point of vew we need to define categorica exponential
   $f: A^B$, which are analogue to functions $f: A \rightarrow B$.
   As we already defined the products and terminals we could define an exponentials with three
   axioms of function construction, one eliminator of application with apply a function to its argument
   and axiom of currying the function of two arguments to function of one argument.

\begingroup
\parbox[t][][l]{0.40\textwidth}{

\begin{prooftree}
\AxiomC{$\Gamma  x:A \vdash M : B$}
\UnaryInfC{$\Gamma \vdash \lambda\ x\ .\ M : A \rightarrow B$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma\ f:A \rightarrow B$ }
\AxiomC{$\Gamma\ a:A$ }
\BinaryInfC{$\Gamma \vdash apply\ f\ a\ : (A \rightarrow B) \times A \rightarrow B$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash f: A \times B \rightarrow C$ }
\UnaryInfC{$\Gamma \vdash curry\ f : A \rightarrow (B \rightarrow C)$}
\end{prooftree}

}
\hspace{0.1cm}
\parbox[t][][r]{0.60\textwidth}{

\begin{center}
$apply \circ \langle (curry\ f) \circ \pi_1 , \pi_2 \rangle = f$\\
$curry\ apply \circ \langle g \circ \pi_1, \pi_2 \rangle) = g$\\
$apply \circ \langle curry\ f, g \rangle = f \circ \langle id , g\rangle$\\
$(curry\ f) \circ g = curry\ (f \circ \langle g \circ \pi_1,\pi_2\rangle)$\\
$curry\ apply = id$\\
\end{center}


}
\endgroup

\subsection{$\lambda$-language}

\begin{center}
Objects : $\bot\ |\ \rightarrow\ |\ \times$\\
Morphisms : $id\ |\ f \circ g\ |\ \langle f, g \rangle\ |\ apply\ |\ \lambda\ |\ curry$
\end{center}

  \subsection{Functors, $\Lambda$-calculus}

  Functor comes as a notion of morphisms in categories whose objects are categories.
  Functors preserve compositions of arrows and identities, otherwise it would
  be impossible to deal with categories. One level up is notion of morphism between categories whose
  objects are Functors, such morphisms are called natural transformations. Here we need
  only functor definition which is needed as general type declarations.

\begin{prooftree}
\AxiomC{$\Gamma \vdash f\ :\ A \rightarrow B$}
\UnaryInfC{$\Gamma \vdash F\ f\ :\ (A \rightarrow B) \rightarrow (F\ a \rightarrow F\ b)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash id_A\ :A \rightarrow A$}
\UnaryInfC{$\Gamma \vdash F\ id_A\ =\ id_{F A}\ :\ F\ A \rightarrow F\ A$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash f\ :B \rightarrow C,\ g : A \rightarrow B$}
\UnaryInfC{$\Gamma \vdash F\ f \circ F\ g\ =\ F (f \circ g)\ :\ F\ A \rightarrow F\ C$}
\end{prooftree}

   We start thinking of functors on dealing with typed theories, because functors usually
   could be seen as higher order type con

\newpage




\newpage
   \subsection{Algebras}

   F-Algebras gives us a categorical understanding recursive types.
   Let $F : C \rightarrow C$ be an endofunctor on category $C$.
   An F-algebra is a pair $(C, \phi)$, where C is an object and $\phi\ : F\ C \rightarrow C$
   an arrow in the category C. The object C is the carrier and the functor
   F is the signature of the algebra. Reversing arrows gives us F-Coalgebra.

\vspace{1cm}

\begin{center}
\begin{tabular}{lcl}
\begin{tikzcd}
  F\ C \arrow{d}[left]{F\ f} \arrow{r}{\varphi} & C \arrow{d}{f} \\
  F\ D \arrow{r}{\psi} & D \end{tikzcd} & & \begin{tikzcd}
  C \arrow{d}[left]{f} \arrow{r}{\varphi} & F\ C \arrow{d}{F\ f} \\
  D \arrow{r}{\psi} & F\ D \end{tikzcd} \\
  \ & \  &\  \\
  $f \circ \varphi = \psi \circ F\ f$ & & $\psi \circ f =  F\ f \circ \varphi$ \\
\end{tabular}
\end{center}

  \subsection{Initial Algebras}

  A F-algebra $(\mu F, in)$ is the initial F-algebra if for any F-algebra $(C, \varphi)$
  there exists a unique arrow $\llparenthesis \varphi \rrparenthesis : \mu F \rightarrow C$ where $f = \llparenthesis \varphi \rrparenthesis$
  and is called catamorphism. Similar a F-coalgebra $(\nu F, out)$ is the terminal
  F-coalgebra if for any F-coalgebra $(C, \varphi)$ there exists unique arrow
  $\llbracket \varphi \rrbracket : C \rightarrow \nu F$ where $f = 
  \llbracket \varphi \rrbracket$

\begin{center}
\begin{tabular}{lcl}
\begin{tikzcd}
  F\ \mu F \arrow{d}[left]{F\ \llparenthesis \varphi \rrparenthesis} \arrow{r}{in} & \mu F \arrow{d}{\llparenthesis \varphi \rrparenthesis} \\
  F C \arrow{r}{\varphi} & C \end{tikzcd} & & \begin{tikzcd}
  C \arrow{d}[left]{ \llbracket \varphi \rrbracket} \arrow{r}{\phi} & F\ C\arrow{d}{F\ \llbracket \varphi \rrbracket} \\
  \nu F \arrow{r}{out} & F \nu F\end{tikzcd} \\
  \ & \  &\  \\
  $f \circ in = \varphi \circ F\ f \equiv f = \llparenthesis \varphi \rrparenthesis$& &
  $out \circ f = F\ f \circ \varphi \equiv f = \llbracket \varphi \rrbracket$ \\
\end{tabular}
\end{center}

   \subsection{Recursive Types}

  As was shown by Wadler\cite{recursive} we could deal with recusrive equations having
  three axioms: one $fix: (A \rightarrow A) \rightarrow A$ fixedpoint axiom,
  and axioms $in: F\ T \rightarrow T$ and $out: T \rightarrow F\ T$ of recursion direction. We need to
  define fixed point as axiom because we can't define recursive axioms. This axioms
  also needs functor axiom defined earlier.


\begingroup
\parbox[t][][l]{0.40\textwidth}{

\begin{prooftree}
\AxiomC{$\Gamma  \vdash M : F\ (\mu\ F)$}
\UnaryInfC{$\Gamma \vdash in_{\mu F}\ M : \mu\ F$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma  \vdash M : \mu F$}
\UnaryInfC{$\Gamma \vdash out_{\mu F}\ M : F\ (\mu\ F)$}
\end{prooftree}

}
\hspace{0.1cm}
\parbox[t][][r]{0.60\textwidth}{


\begin{prooftree}
\AxiomC{$\Gamma  \vdash M : A \rightarrow A$}
\UnaryInfC{$\Gamma \vdash fix\ M : A$}
\end{prooftree}

}
\endgroup

\newpage
\section{Type Theory}

   \subsection{Intuitionistic Type Theory}

   \paragraph{}
   Using Build Yourself Type Teory approach sooner or later
   you should decide the pallete of inductive structures. Such in Coq
   abstract algebra framework was built upon polymorphic records\cite{coqalg} rather
   that type classes engine like it is used in Agda and Idris. However
   Idris still lack of polymorphic records and coinductive types. Lean also
   lack of coinductive structures but has powerful non-recursive polymorphic records
   which are used in Lean HoTT library.

   \paragraph{}
   As was show by Spephan Kaes\cite{kaes}, one of strategy of type clasess engine
   implementataion is using polymorphic structures which allows us do deal with
   persistent structures on a low theoretical level. Moreover this style of coding
   is completly compatible with Erlang records which are used to model KVS and N2O hierarchies.

  \subsection{Universes}

\begin{equation}
\tag{sorts}
\dfrac
  {i : Nat}
  {Type_i}
\end{equation}

\begin{equation}
\tag{axioms}
\dfrac
  {i: Nat}
  {Type_i : Type_{i+1}}
\end{equation}

\begin{equation}
\tag{rules}
\dfrac
  {i : Nat,\ \ \ \ j : Nat}
  {Type_i \rightarrow Type_{j} : Type_{max(i,j)}}
\end{equation}

  \subsection{Dependent Types}

\begin{equation}
\tag{subst}
\dfrac
  {\pi_1 : A\ \ \ \ u:A \vdash \pi_2 : B}
  {[\pi_1/u]\ \pi_2 : B}
\end{equation}

\begin{equation}
\tag{$\Pi$-formation}
\dfrac
  {x:A \vdash B : Type}
  {\Pi\ (x:A) \rightarrow B : Type}
\end{equation}

\begin{equation}
\tag{$\lambda$-intro}
\dfrac
  {x:A \vdash b : B}
  {\lambda\ (x:A) \rightarrow b : \Pi\ (x: A) \rightarrow B }
\end{equation}

\begin{equation}
\tag{$App$-elimination}
\dfrac
  {f: (\Pi\ (x:A) \rightarrow B)\ \ \ a: A}
  {f\ a : B\ [a/x]}
\end{equation}

\begin{equation}
\tag{$\beta$-computation}
\dfrac
  {x:A \vdash b: B\ \ \ a:A}
  {(\lambda\ (x:A) \rightarrow b)\ a = b\ [a/x] : B\ [a/x]}
\end{equation}

  \subsection{Equality Types}

\begin{equation}
\tag{$Id$-formation}
\dfrac
  {x:A\ \ \ \ b:A\ \ \ \ A:Type}
  {Id(A,a,b) : Type}
\end{equation}

\begin{equation}
\tag{$Id$-intro}
\dfrac
  {a:A}
  {refl(A,a) : Id(A,a,a) }
\end{equation}

\begin{equation}
\tag{$J$-elimination}
\dfrac
  {p:Id(a,b)\ \ \ \ x,y:A\ \ \ \ u:Id(x,y) \vdash E:Type\ \ \ \ x:A \vdash d: E\ [x/y,\ refl(x)/u]}
  {J(a,b,p,(x,y,u)\ d) : E\ [a/x,\ b/y,\ p/u]}
\end{equation}

\begin{equation}
\tag{$Id$-computation}
\dfrac
  {a,x,y:A,\ \ \ \ u:Id(x,y) \vdash E:Type\ \ \ \ x:A \vdash d:E\ [x/y,\ refl(x)/u]}
  {J(a,a,refl(a),(x,y,u)\ d) = d\ [a/x] : E\ [a/y,\ refl(a)/u]}
\end{equation}

  \subsection{Inductive Types}

\begin{equation}
\tag{$W$-formation}
\dfrac
  {A:Type\ \ \ \ x:A\ \ \ \ B(x):Type}
  {W (x:A) \rightarrow B(x) : Type}
\end{equation}

\begin{equation}
\tag{$W$-intro}
\dfrac
  {a:A\ \ \ \ t: B(a) \rightarrow W}
  {sup(a,t) : W}
\end{equation}

\begin{equation}
\tag{$W$-elimination}
\dfrac
  {w: W \vdash C(w) : Type\ \ \ \ x:A,\ u:B(x) \rightarrow W,\ \ \ \ v:\Pi (y:B(x)) \rightarrow C(u(y)) \vdash c(x,u,v):C(sup(x,u))}
  {w:W \vdash wrec(w,c):C(w)}
\end{equation}

\begin{equation}
\tag{$W$-computation}
\dfrac
  {w: W \vdash C(w) : Type\ \ \ \ x:A,\ u:B(x) \rightarrow W,\ \ \ \ v:\Pi (y:B(x)) \rightarrow C(u(y)) \vdash c(x,u,v):C(sup(x,u))}
  {x:A,\ \ \ \ u:B(x) \rightarrow W \vdash wrec(sup(x,u),c)\ =\ c(x,u,\lambda (y:B(x)) \rightarrow wrec(u(y),c)):C(sup(x,u))}
\end{equation}

\subsection{Recursor}

There is a belief that recursor (non-dependent eliminator) in Type Theory
is a weaker property than induction principle (dependent eliminator). At the same time
from category theory we know that Universal Property defines the object uniquely.
In the case of initial object in the category of algebras, the initiality could be defined by recursor.
That means that all properties of algebra follow from its initiality,
as a case it is possible to get the recursor from induction. There is a sensitive moment here,
all categorical constructions are being formulated with defined equality on morphisms,
in type theory the equality is built-in type that could have extended properties. Simplify we could say
that we can get recursor from induction without equality, and with proper equality we could get induction from recursor.

\subsection{Fibrations}

Mechanism of getting induction principle from equality is based on the presentation
of dependent types through fibrations. Hereby dependent type $(D: B \rightarrow Type)$ is defined as $(p: Sigma\ B\ P \rightarrow B)$
which projects dependent pair to the first field. In topology such approach is called fibration.
To the other direction for a given morphism $(p: E \rightarrow B)$ which we understands as fibration with projection p,
we could get its dependent type as $(D: B \rightarrow Type)$ by calculation in every point $(b: B)$ its image of
projection p by using equality on elements of $B$. In type theory besides depndent pair $Sigma$ also
used the dependent product $Pi$. In encoding of dependent types with fibrations there is a correspondance
between elements of dependent and morphism-fibrations for projection $p$: such $(s: B \rightarrow E)$ that $s * p = I$.
The example of this implementaion could be seen in\\
\\
EXE\footnote{https://github.com/groupoid/exe/blob/master/prelude/macro.new/Mini.macro}
OM\footnote{https://github.com/groupoid/om/blob/master/priv/posets/sec2all}

\subsection{Induction}

The input for induction is a predicate — dependent type encoded with $(p: E \rightarrow B)$.
Induction needed additional information for predicate. The type of induction is defined
by set of inductive constructors. Induction is just a statement that on E we have the
structure of F-algebra of inductive type. Now we could apply recursor to E
getting the map $(I \rightarrow E)$ from initial object which in fact the section (fibre bundle) of fibration
and thus defines the dependent function which is a proved value of induction principle.
The example for $Bool$ could be found in\\
\\
EXE \footnote{https://github.com/groupoid/exe/blob/master/prelude/macro.new/Data.Bool.macro}
OM \footnote{https://github.com/groupoid/om/blob/master/priv/posets/Data/Bool/induc}\\
\\
Summarizing we encode types of source lambda calculus with objects of selected category,
dependent types with fibrations, dependent function as fibrations, inductive types as
limits of identity functors on category of F-algebras.

%\begin{thebibliography}{9}
%\end{thebibliography}
%\newpage

\end{document}
