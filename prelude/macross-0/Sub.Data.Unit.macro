import minimal

namespace Data
namespace Unit

def Alg.Ob : Type.{u,p} := record
    ( Carrier : Poset.Ob.{u,p} )
    ( Mk : [Carrier] ) -- research

def Alg.Hom (A1, A2 : Alg.Ob) : Poset.Ob :=
    let (C1 := A1.Carrier) (C2 := A2.Carrier) in
    Poset.Ob.mk
        ( El := |C1 ⥤ C2| )
        ( To m1 m2 := packed record
            (mk1 : (m1 A1.Mk.el) =C2= A2.Mk.el)
            (equ : m1 =(C1 ⥤ C2)= m2) )
        ( Trans m1 m2 m3 to12 to23 := To.mk m1 m3
                (mk1 := to12.mk1)
                (equ := .Trans (C1 ⥤ C2) m1 m2 m3 to12.equ to23.equ) )

-- sugar (A1 ⟹ A2)

def Alg.Id (A : Alg.Ob) : [A ⟹ A] :=
    let (setid := Poset.Id A.Carrier) in
    brackets.mk (A ⟹ A)
        ( el := setid.el )
        ( ok := Alg.Hom.To.mk A A El El
            (mk1 := .Refl A.Carrier A.Mk)
            (equ := setid.ok) )

def Alg.Mul.onEl (A1, A2, A3 : Alg.Ob)
    (m23 : [A2 ⟹ A3]) (m12 : [A1 ⟹ A2]) : [A1 ⟹ A3] :=
    let (setmul := Poset.Mul.onEl A1.Carrier A2.Carrier A3.Carrier m23.hom m12.hom) in
    brackets.mk (A1 ⟹ A3)
        ( el := setmul.el )
        ( ok := Alg.Hom.To.mk A1 A3 El El
            ( mk1 := .Trans A3.Carrier
                (m23 $ (m12 $ A1.Mk))
                (m23 $ A2.Mk)
                (A3.Mk)
                (m23.hom $/ m12.Ok.mk1)
                (m23.Ok.mk1) )
            ( equ := setmul.ok ) )

def Init : Alg.Ob := Alg.Ob.mk
    ( Carrier := Poset.Ob.mk.{u,p}
        ( El :=
            ∀ (A : Alg.Ob) →
            A.Carrier )
        ( To := λ (e1, e2 : El) →
            ∀ (A1, A2 : Alg.Ob) → ∀ (hom : [A1 ⟹ A2]) →
            ((hom $ (e1 A1)) =A2.Carrier= (e2 A2)) )
        ( Trans :=
            λ (e1, e2, e3 : El) →
            λ (to12 : To e1 e2) → λ (to23 : To e2 e3) →
            λ (A1, A2 : Alg.Ob) → λ (hom : [A1 ⟹ A2]) →
            (.Trans T (e1 A1) (e2 A1) (e3 A2) (to12 A) (to23 A)) )
    ( Mk := Carrier.El.mk
        ( atOb :=
            λ (A : Alg.Ob) →
            A.Mk )
        ( atHom :=
            λ (A1, A2 : Alg.Ob) → λ (hom : [A1 ⟹ A2]) →
            hom.homMk ))

def recur.forOb (A : Alg.Ob) : [ Init ⟹ A ] :=
    Alg.Hom.mk Init A
        ( hom := λ (u : [Init.Carrier]) → (.atOb u A) )
        ( homMk := .Refl A.Carrier A.Mk )

def recur.forHom (A1, A2 : Alg.Ob) (hom : [A1 ⟹ A2])
    : (Alg.Mul.onEl Init A1 A2 hom (recur.forOb A1))
        =[ Init ⟹ A2 ]= (recur.forOb A2) :=
    λ (u : [Init.Carrier]) → (.atHom u A1 A2 hom)

def Endo : Poset.Ob := Init ⟹ Init

def IId : [Endo] := Alg.Id Init

def recur.forId : (recur.forOb Init) =Endo= IId :=
    λ (u : [Init.Carrier]) →
    λ (A : Alg.Ob) →
    (.atHom u Init A (recur.forOb A)) u

def Predicate : Poset.Ob.{p, p} := PredicateSet Init.Carrier

def Sigma (P : [Predicate]) (mk : P $ Init.Mk) : Alg.Ob :=
    ( Carrier := SmallSigmaSet Init.Carrier P )
    ( Mk := SmallSigmaSet.El.mk Init.Carrier P
        ( base := Init.Mk )
        ( pred := mk ) )

def SInj (P : [Predicate]) (mk : P $ Init.Mk)
    : [ (Sigma P mk) ⟹ Init ] :=
    Alg.Hom.mk (Sigma P mk) Init
        ( hom := Pred2Sub.i Init.Carrier P )
        ( homMk := .Refl Init.Carrier Init.Mk )

def recurP.forOb (P : [Predicate]) (mk : P $ Init.Mk)
    : [ Init ⟹ (Sigma P mk) ] :=
    recur.forOb (Sigma P mk)

def recurP.forHom (P : [Predicate]) (mk : P $ Init.Mk)
    : (Alg.Mul.onEl Init (Sigma P mk) Init (SInj P mk) (recurP.forOb P mk))
        =Endo= (recur.forOb Init) :=
    recur.forHom (Sigma P mk) Init (SInj P mk)

def section (P : [Predicate]) (mk : P $ Init.Mk)
    : isSection Init.Carrier (Pred2Sub Init.Carrier P) (recur.forOb.hom (Sigma P mk)) :=
    .Trans Endo
        (Alg.Mul.onEl Init (Sigma P mk) Init (SInj P mk) (recurP.forOb P mk))
        (recur.forOb Init)
        IId
        (recurP.forHom P mk)
        recur.forId

def induc (P : [Predicate]) (mk : P $ Init.Mk)
    : Forall.{u,p} Init.Carrier P :=
    sec2all Init.Carrier P (recurP.forOb.hom P mk) (section P mk)

end Unit
end Data
