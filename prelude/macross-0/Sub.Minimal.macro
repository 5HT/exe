--
-- even more minimal macross example
--

-- universes
def Type.{t} : *.{t+1} := *.{t}
def Prop.{p} : *.{p+1} := *.{p}

-- church encoding for Prop

namespace Prop

    -- Prod0 = True; Prod2 = And;

    def Prod0.{p} : Prop.{p} :=
        ∀ (True : Prop.{p}) →
        ∀ (Mk : True) →
        True

    def Prod0.Mk.{p} : Prod0.{p} :=
        λ (True : Prop.{p}) →
        λ (Mk : True) →
        Mk

    def Prop0.elim.{p} (True : Prop.{p}) (Mk : True) (true : Prod0.{p}) : True :=
        true True Mk

    def Prod2.{p} (A, B : Prop.{p}) : Prop.{p} :=
        ∀ (And : Prop.{p}) →
        ∀ (Mk : A → B → And) →
        And

    def Prod2.Mk.{p} (A, B : Prop.{p})
        (a : A) (b : B) : Prod2.{p} A B :=
        λ (And : Prop.{p}) →
        λ (Mk : A → B → And) →
        Mk a b

    def Prop2.elim.{p} (A, B : Prop.{p}) (And : Prop.{p})
        (Mk : A → B → And) (and : Prod2.{p} A B) : And :=
        and And Mk

    -- aka DEP.AND
    def Sigma.{p} (A : Prop.{p}) (B : A → Prop.{p})
        : Prop.{p} :=
        ∀ (P : Prop.{p}) →
        ∀ (Mk : ∀ (a : A) → ∀ (b : B a) → P) →
        P

    def Sigma.Mk.{p} (A : Prop.{p}) (B : A → Prop.{p})
        (a : A) (b : B a) : Sigma.{p} A B :=
        λ (P : Prop.{p}) →
        λ (Mk : ∀ (a : A) → ∀ (b : B a) → P) →
        Mk a b

    def Sigma.pr1 (A : Prop.{p}) (B : A → Prop.{p})
        (s : Sigma A B) : A :=
        s A (λ (a : A) → λ (b : B a) → a)

    def Sigma.pr2 (A : Prop.{p}) (B : A → Prop.{p})
        (B.Cong : ∀ (a1, a2 : A) → (B a1 → B a2))
        (s : Sigma A B) : B (Sigma.pr1 s) :=
        s (B (Sigma.pr1 s)) (λ (a : A) → λ (b : B a) → B.cong a (Sigma.pr1 s) b)

    def Sigma.induc (A : Prop.{p}) (B : A → Prop.{p})
        (s : Sigma A B)
        (P : Sigma A B → Prop.{p})
        (P.cong : ∀ (s1, s2 : Sigma A B) → (P s1 → P s2))
        (mk : ∀ (a : A) → ∀ (b : B a) → P (Sigma.Mk a b))
        : P s :=
        s (P s) (λ (a : A) → λ (b : B a) → P.cong (Sigma.Mk a b) s (mk a b))

    def church.{p} : encoding.{p} :=
        encoding.mk Prod0.{p} Prod0.Mk.{p} Prod2.{p} Prod2.Mk.{p} Prod2.elim.{p}

end Prop

namespace Setoid

    def Ob.{u, p} : Type.{(u+1,p+1,p)} := record
        (El : Type.{u})
        (Equ : ∀(e1, e2 : El) → Prop.{p})
        (Trans : ∀(e1, e2, e3 : El) → Equ e1 e2 → Equ e2 e3 → Equ e1 e3)

    def Ob.Ok (S : Ob) (el : El) → Prop := S.Equ el el
    def Ob.brackets (S : Ob) : Type := record (El : Ob.El) (Ok : Ob.Ok S El)

--  sugar ( [A] ), (a1 ≡A≡ a2)

    def Hom.{u1, p1, u2, p2} (A : Ob.{u1, p1}) (B : Ob.{u2, p2})
        : Ob.{u2, p2} := Ob.mk
        ( El := A.El → B.El )
        ( Equ := λ(f1, f2 : El) → ∀(a1, a2 : A.El) →
            (a1 ≡A≡ a2) → ((f1 a1) ≡B≡ (f2 a2)))
        ( Trans := λ(f1, f2, f3 : El) →
            λ(equ12 : Equ f1 f2) → λ(equ23 : Equ f2 f3) →
            λ(a1, a2 : A.El) → .Trans B (f1 a1) (f2 a1) (f3 a2) (equ12 a1 a1) (equ23 a1 a2))

--  sugar (A ⥤ B), (f $ x), (f $/ xEqu), (fEqu /$ x)

    def Arrow (A, B : Ob) := [A ⥤ B]

    def Id.{u1, p1} (A : Ob.{u1, p1}) : [A ⥤ A] := Arrow.mk A A
        ( El := λ (a : A.El) → a )
        ( Ok := λ (a1, a2 : A.El) → Prop.id (a1 ≡A≡ a2))

    def Mul.onEl.{u1, p1, u2, p2, u3, p3} (A : Ob.{u1, p1}) (B : Ob.{u2, p2}) (C : Ob.{u3, p3})
        (f : [B ⥤ C]) (g : [A ⥤ B]) : [A ⥤ C] := Arrow.mk A C
        ( El := λ (a : A.El) → (f $ (g $ a)))
        ( Ok := λ (a1, a2 : A.El) → λ(equ12 : a1 ≡A≡ a2) → (f $/ (g $/ equ12)) )

end Setoid

--
def PropSet.{p} : Setoid.Ob.{p, p} := Setoid.Ob.mk.{p, p}
    (El := Prop.{p})
    (Equ := P1 → P2)
    (Trans := λ (P1, P2, P3 : El) → λ (equ12 : Equ e1 e2) → λ (equ23 : Equ e2 e3) →
        Prop.mul P1 P2 P3 equ23 equ12)

--
def PredicateSet.{u, p} (X : Setoid.Ob.{u, p}) : Setoid.Ob.{p, p} :=
    X ⥤ PropSet.{p};

def Pred (X : Setoid.Ob) := [PredicateSet X]

--
def SmallSigmaSet.{u, p} (B : Setoid.Ob.{u, p}) (P : [PredicateSet.{u, p} B]) : Setoid.Ob.{u, p} :=
    Setoid.Ob.mk.{u, p}
    ( El := B.El )
    ( Equ := λ (b1, b2 : El) → record
        (pred1 : P.El b1)
        (pred2 : P.El b2)
        (equ : b1 ≡A≡ b2) )
    ( Trans := λ (b1, b2, b3 : El) →
        λ (equ12 : Equ e1 e2) → λ (equ23 : Equ e2 e3) →
        Equ.mk b1 b3
            (pred1 := equ12.pred1)
            (pred2 := equ23.pred2)
            (equ := .Trans B b1 b2 b3 equ12.equ equ23.equ) )

--
def SubsetType.{u, p} (B : Setoid.Ob.{u, p}) : Type.{(u+1,p+1,p),(u,p),p} :=
    record
        (A : Setoid.Ob.{u, p} )
        (i : [A ⥤ B] )
        (uniq : ∀(a1, a2 : [A]) → ((i.El a1.El) ≡B≡ (i.El a2.El)) → (a1.El ≡A≡ a2.El) )

--
def Pred2Sub.{u, p} (B : Setoid.Ob.{u, p}) (P : [PredicateSet.{u, p} B]) : SubsetType.{u,p} B :=
    SubsetType.mk.{u,p}
        ( A := SmallSigmaSet B P )
        ( i := Arrow.mk A B
            ( El := λ (a : A.El) → a )
            ( Ok := λ (a1, a2 : A.El) → λ (equ12 : a1 ≡A≡ a2) → equ12.equ)
        ( uniq := λ (a1, a2 : [A]) → λ (equ12 : a1.El ≡B≡ a2.El) →
            SmallSigmaSet.mk B P a1.El a2.El
                ( pred1 := a1.Ok.pred1 )
                ( pred2 := a1.Ok.pred2 )
                ( equ := equ12) )

--
def Sub2Pred.{u, p} (B : Setoid.Ob.{u, p}) (S : SubsetType.{u, p} B) : [PredicateSet.{u, p} B] :=
    Pred.mk
        ( El := λ (b : B.El) → packed church.{p} record
            (a : S.A.El)
            (equ : (S.i $ a) ≡B≡ b) )
        ( Ok := λ (b1, b2 : B.El) → λ (equ12 : b1 ≡B≡ b2) →
            ( λ (pair : El b1) → El.mk b2
                ( a := pair.1 )
                ( equ := .Trans B (S.i $ a1) b1 b2 pair.equ equ12) )

--
def isSection.{u, p} (B : Setoid.Ob.{u, p}) (S : SubsetType.{u, p} B)
        (f : [B ⥤ S.A]) : Prop.{p} :=
    (Setoid.Mul.onEl B S.A B S.i f) ≡B≡ (Setoid.Id B)

--
def Forall.{u, p} (B : Setoid.Ob.{u, p}) (P : [PredicateSet.{u, p} B]) : Prop.{p} :=
    ∀ (b : [B]) → (P $ b.El)

--
def sec2all.{u, p} (B : Setoid.Ob.{u, p}) (P : [PredicateSet.{u, p} B])
        (f : [B ⥤ SmallSigmaSet B P]) (sec : isSection B (Pred2Sub B P) f)
        : Forall.{u,p} B P :=
    ∀ (b : [B]) → ((P $/ (sec /$ b)) (.pred (f [$] b)))

--
