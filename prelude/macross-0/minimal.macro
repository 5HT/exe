--
-- minimal macross example
--

-- universes
def Type.{t} : *.{t+1} := *.{t}
def Prop.{p} : *.{p+1} := *.{p}

-- church encoding for Prop

namespace Prop

    -- Prod0 = True; Prod2 = And;

    def Prod0.{p} : Prop.{p} :=
        ∀ (True : Prop.{p}) →
        ∀ (Mk : True) →
        True

    def Prod0.Mk.{p} : Prod0.{p} :=
        λ (True : Prop.{p}) →
        λ (Mk : True) →
        Mk

    def Prop0.elim.{p} (True : Prop.{p}) (Mk : True) (true : Prod0.{p}) : True :=
        true True Mk

    def Prod2.{p} (A, B : Prop.{p}) : Prop.{p} :=
        ∀ (And : Prop.{p}) →
        ∀ (Mk : A → B → And) →
        And

    def Prod2.Mk.{p} (A, B : Prop.{p}) (a : A) (b : B) : Prod2.{p} A B :=
        λ (And : Prop.{p}) →
        λ (Mk : A → B → And) →
        Mk a b

    def Prop2.elim.{p} (A, B : Prop.{p}) (And : Prop.{p}) (Mk : A → B → And) (and : Prod2.{p} A B) : And :=
        and And Mk

    def church.{p} : encoding.{p} := encoding.mk Prod0.{p} Prod0.Mk.{p} Prod2.{p} Prod2.Mk.{p} Prod2.elim.{p}

end Prop

namespace Setoid

    def Ob.{u p} : Type.{(u+1,p+1,p+1,p,p,p)} :=
        record
        (El : Type.{(u,p)})
        (Equ : ∀(e1, e2 :(.1 El)) → Prop.{p})
        (Refl : ∀(e0 : (.1 El)) → Equ e0 e0)
        (Trans : ∀(e1, e2, e3 : (.1 El)) → Equ e1 e2 → Equ e2 e3 → Equ e1 e3)
        (Sym : ∀(e1, e2 : (.1 El)) → Equ e1 e2 → Equ e2 e1)

--  notation (a1 ≡A≡ a2)

    def Hom.{u} (A, B : Ob.{u}) : Ob.{u} :=
        Ob.mk
        ( El := record.{((.1 onEl), church (.2 onEl) onEqu)}
            (onEl : .El A → .El B)
            (onEqu : ∀(a1, a2 : .El A) → (a1 ≡A≡ a2) → ((onEl a1) ≡B≡ (onEl a2))))
        ( Equ := λ(f, g : El) → ∀(a : A) → ((f a) ≡B≡ (g a)))
        ( Refl := λ(f0 : El) → λ(a : .El A) → (.Refl A (f0 a)))
        ( Trans := λ(f1, f2, f3 : El) → λ(equ12 : Equ f1 f2) → λ(equ23 : Equ f2 f3) →
                λ(a : .El A) → .Trans A (f1 a) (f2 a) (f3 a) (equ12 a) (equ23 a))
        ( Sym := λ(f1, f2 : El) → λ(equ12 : Equ f1 f2) →
                λ(a : .El A) → .Sym A (f1 a) (f2 a) (equ12 a))

--  notation (f $ x) (f $/ xEqu) (fEqu /$ x)

    def Mul.onEl.{u} (A, B, C : Ob.{u})
        (f : Hom.El.{u} B C) (g : Hom.El.{u} A B) : Hom.El.{u} A C :=
        Hom.El.mk.{u} A C
            ( λ (a : .El A) → f $ (g $ a))
            ( λ (a1, a2 : .El A) → λ(a12 : a1 ≡A≡ a2) → f $/ (g $/ a12) )

end Setoid

--
def PropSet.{p pp} : Setoid.Ob.{p pp} := Setoid.Ob.mk.{p pp}
    (El := record.{(P, church)} (P: Prop))
    (Equ := )

--
def DepSet.{u p } : Setoid.Ob.{} := ;
