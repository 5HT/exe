module coproduct_noset where

import proto
import path
import iso
import proto_sigma

-- an endofunctor
T (f: U -> U): U = (a b: U) -> (a -> b) -> (f a -> f b)

-- type TAlg f x = Functor f => (x, f x -> x)
TAlg (f: U -> U) (F: T f) (X: U): U = (f X -> X)

-- From https://en.wikipedia.org/wiki/F-algebra
-- B = f (al FA)
-- B = be (Ff FA)
--
-- (al: a -> f a) (be: b -> f b): (witness : a -> b) * (al . witness == Ff . be)
THom (f: U -> U) (F: T f) (A B: U) (al: TAlg f F A) (be: TAlg f F B): U
  = (ff: A -> B) * Path (FA -> B) (up ff) (down ff) where
  FA : U = f A
  FB : U = f B
  up   (f: A -> B): FA -> B = o FA  A B f  al
  down (f: A -> B): FA -> B = o FA FB B be Ff where
    Ff : FA -> FB = F A B f

-- arbitrary . witness == Ff . initial
TIsInitial (f: U -> U) (F: T f) (A B: U) (initial: TAlg f F A): U = (arbitrary: TAlg f F B) -> THom f F B A arbitrary initial

-- fmap of the identity endofunctor is the identity function between functions
endoId : T (idfun U) = \(a b: U) -> idfun (a -> b)

-- its algebras are "endofunctions"
endoIdAlg (X: U) : U = X -> X

-- its algebra homomorphisms
-- (al: a -> a) (be: b -> b): (witness : a -> b) * (be . witness == witness . al)
endoIdHom (X: U) (al be: X -> X): U = (witness: X -> X) * Path (X -> X) (up witness) (down witness) where
  up   (witness: X -> X): X -> X = o X X X witness  al
  down (witness: X -> X): X -> X = o X X X be       witness

-- a non-trivial and non-identity example of Id-algebra homomorphism (without source code):
-- affine transformations of the real axis
-- x * 2 + 12   = (x + 6) * 2
-- (+12) . (*2) = (*2) . (+6)
-- so (*2) witnesses the homomorphism between (+6) and (+12)


unitEnc' : U = (X: U) -> X -> X

unitEnc : U
  = (al : unitEnc') * ((X Y: U) -> (f: X -> Y) ->
    Path (X -> Y) (o X X Y f (al X)) (o X Y Y (al Y) f))

unitEncStar : unitEnc = (\(X: U) -> idfun X, (\(X Y: U) -> refl (X -> Y)))

unitEncRec (C: U) (c: C): unitEnc -> C
  = \(z: unitEnc) -> z.1 C c

-- lemma 2.4.3
unitEncBeta (C: U) (c: C): Path C (unitEncRec C c unitEncStar) c = refl C c

-- lemma 2.4.4

sigPath1 (A: U) (P: A -> U) (a b: Sigma A P) (p: Path (Sigma A P) a b): Path A a.1 b.1
 = undefined

-- funExt2 (A B C: U) (f g: A -> B -> C) (p: (a: A) (b: B) -> Path (f a b) (g a b)): Path (A -> B -> C) f g = undefined

setFun (X Y: U) (proofX : isSet X) (proofY: isSet Y)
  : isSet (X -> Y)
  = undefined

upPath (X Y: U) (f: X -> Y) (al : X -> X): X -> Y = o X X Y f al
downPath (X Y: U) (f: X -> Y) (be: Y -> Y): X -> Y = o X Y Y be f

propPathFun (X Y: U) (proofX: isSet X) (proofY: isSet Y) (f g: X -> Y)
  : isProp (Path (X -> Y) f g)
  = setFun X Y proofX proofY f g

propUnitEncCondition (X Y: U) (proofX: isSet X) (proofY: isSet Y) (al' : (A: U) (proofA: isSet A) -> A -> A)
  : isProp ((f: X -> Y) -> Path (X -> Y) (upPath X Y f (al' X proofX)) (downPath X Y f (al' Y proofY)))
   = lem2 where
  PP (f: X -> Y): U = Path (X -> Y) (upPath X Y f (al' X proofX)) (downPath X Y f (al' Y proofY))

  lem1 (f: X -> Y): isProp (PP f)
    = propPathFun X Y proofX proofY (upPath X Y f (al' X proofX)) (downPath X Y f (al' Y proofY))
  lem2
    : isProp           ((f: X -> Y) -> PP f)
    = propPi (X -> Y) (\(f: X -> Y) -> PP f) lem1

unitEncWeakEta (z: unitEnc): Path unitEnc (z.1 unitEnc unitEncStar) z = goal where
  P (al: (X : U) -> X -> X): U = ((X Y: U) -> (f: X -> Y) ->
    Path (X -> Y) (o X X Y f (al X)) (o X Y Y (al Y) f))
  al : unitEnc' = z.1
  p : P al = z.2

  alStar : unitEnc = al unitEnc unitEncStar
  alStarAl: unitEnc' = alStar.1
  alStarP: P alStarAl = alStar.2
  goal : Path unitEnc (al unitEnc unitEncStar) z
    = pathSig3 A P alStar z (q,t) where
    A : U = unitEnc'

    -- proposition 2.4.5
    qq (X: U) (x: X): Path X (alStarAl X x) (al X x) = funExtInv unitEnc X ff gg pp unitEncStar where
      f: unitEnc -> X = unitEncRec X x
      ff : unitEnc -> X = o unitEnc unitEnc X f (al unitEnc)
      gg : unitEnc -> X = o unitEnc X X (al X) f
      pInst : U = Path (unitEnc -> X) ff gg where
        f: unitEnc -> X = unitEncRec X x
      pp : pInst = p unitEnc X (unitEncRec X x)

    qqEta (X: U): Path (X -> X) (alStarAl X) (al X) = funExtNonDep X X (alStarAl X) (al X) (qq X)

    q: Path unitEnc' alStar.1 al = funExt U (\(X: U) -> X -> X) alStarAl al qqEta

    p' : Path U (P alStar.1) (P z.1) = mapOnPath unitEnc' U P alStar.1 z.1 q
    t: Path (P z.1) (transport p' alStar.2) z.2 = undefined --  proofP z.1 (transport p' alStar.2) z.2
