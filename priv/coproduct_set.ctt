module coproduct_set where

import proto
import path
import iso
import propset
import proto_sigma

-- shortcuts
upPath (X Y: U) (f: X -> Y) (al : X -> X): X -> Y = o X X Y f al
downPath (X Y: U) (f: X -> Y) (be: Y -> Y): X -> Y = o X Y Y be f

naturality (X Y: U) (al: X -> X) (be: Y -> Y) (f: X -> Y): U
  = Path (X -> Y) (upPath X Y f al) (downPath X Y f be)

unitEnc' : U = (X: U) -> isSet X -> X -> X

-- encodings of Unit, tt and the recursor/non-dependent eliminator/catamorphism respectively
unitEnc : U
  = (al : unitEnc') * (X Y: U) -> (proofX: isSet X) -> (proofY: isSet Y) -> (f: X -> Y) ->
    naturality X Y (al X proofX) (al Y proofY) f

unitEncStar : unitEnc = (\(X: U) (_: isSet X) -> idfun X, \(X Y: U) (_: isSet X) (_: isSet Y)-> refl (X -> Y))

unitEncRec (C: U) (proofC: isSet C) (c: C): unitEnc -> C
  = \(z: unitEnc) -> z.1 C proofC c

-- lemma 2.4.3
unitEncBeta (C: U) (proofC: isSet C) (c: C): Path C (unitEncRec C proofC c unitEncStar) c = refl C c

-- lemma 2.4.4 preliminaries (implicit in the paper)

proofUnitEnc: isSet unitEnc = undefined

propUnitEncCondition (X Y: U) (proofX: isSet X) (proofY: isSet Y) (al : unitEnc')
  : isProp ((f: X -> Y) -> naturality X Y (al X proofX) (al Y proofY) f)
  = lem2 al where
  PP (al : unitEnc') (f: X -> Y): U = naturality X Y (al X proofX) (al Y proofY) f

  lem1 (al: unitEnc') (f: X -> Y): isProp (PP al f)
    = setFun X Y proofY (upPath X Y f (al X proofX)) (downPath X Y f (al Y proofY))
  lem2 (al : unitEnc')
    : isProp           ((f: X -> Y) -> PP al f)
    = propPi (X -> Y) (\(f: X -> Y) -> PP al f) (lem1 al)
  lem3
    : isProp           ((al : unitEnc') -> (f: X -> Y) -> PP al f)
    = propPi unitEnc' (\(al : unitEnc') -> (f: X -> Y) -> PP al f) lem2

-- lemma 2.4.4
unitEncWeakEta (z: unitEnc): Path unitEnc (z.1 unitEnc proofUnitEnc unitEncStar) z
  = pathSig3 unitEnc' P alStar z (q,t) where
  P (al: (X : U) (proofX: isSet X) -> X -> X): U = (X Y: U) -> (proofX: isSet X) -> (proofY: isSet Y) -> (f: X -> Y) ->
    naturality X Y (al X proofX) (al Y proofY) f
  al : unitEnc' = z.1
  p :  P al = z.2

  alStar : unitEnc = al unitEnc proofUnitEnc unitEncStar
  alStarAl: unitEnc' = alStar.1
  alStarP: P alStarAl = alStar.2

  -- proposition 2.4.5
  q: Path unitEnc' alStarAl al = funExt U (\(X: U) -> isSet X -> X -> X) alStarAl al qqEtaEta where
    qq (X: U) (proofX: isSet X) (x: X): Path X (alStarAl X proofX x) (al X proofX x)
      = funExtInv unitEnc X ff gg pp unitEncStar where

      f  : unitEnc -> X = unitEncRec X proofX x
      ff : unitEnc -> X =   upPath unitEnc X f (al unitEnc proofUnitEnc)
      gg : unitEnc -> X = downPath unitEnc X f (al X proofX)
      pp : Path (unitEnc -> X) ff gg = p unitEnc X proofUnitEnc proofX (unitEncRec X proofX x)

    qqEta (X: U) (proofX: isSet X): Path (X -> X) (alStarAl X proofX) (al X proofX)
      = funExtNonDep X X (alStarAl X proofX) (al X proofX) (qq X proofX)

    qqEtaEta (X: U): Path (isSet X -> X -> X) (alStarAl X) (al X)
      = funExtNonDep (isSet X) (X -> X) (alStarAl X) (al X) (qqEta X)

  p' : Path U (P alStar.1) (P z.1) = mapOnPath unitEnc' U P alStar.1 z.1 q
  t: Path (P z.1) (transport p' alStar.2) p = proofP (transport p' alStarP) p where
    proofP : isProp (P al) = undefined
