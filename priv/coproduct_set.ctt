module coproduct_set where

import proto
import path
import iso
import propset

unitEnc' : U = (X: U) -> isSet X -> X -> X

unitEnc : U
  = (al : unitEnc') * ((X Y: U) -> (proofX: isSet X) -> (proofY: isSet Y) -> (f: X -> Y) ->
    Path (X -> Y) (o X X Y f (al X proofX)) (o X Y Y (al Y proofY) f))


unitEncStar : unitEnc = (\(X: U) (proofX: isSet X) -> idfun X, \(X Y: U) (proofX: isSet X) (proofY: isSet Y)-> refl (X -> Y)) 

unitEncRec (C: U) (proofC: isSet C) (c: C): unitEnc -> C
  = \(z: unitEnc) -> z.1 C proofC c

-- lemma 2.4.3
unitEncBeta (C: U) (proofC: isSet C) (c: C): Path C (unitEncRec C proofC c unitEncStar) c = refl C c

-- lemma 2.4.4
{-
unitEncWeakEta (z: unitEnc): Path unitEnc (z.1 unitEnc unitEncStar) z = goal where
  P (al: (X : U) -> X -> X): U = ((X Y: U) -> (f: X -> Y) ->
    Path (X -> Y) (o X X Y f (al X)) (o X Y Y (al Y) f))
  al : unitEnc' = z.1
  p : P al = z.2

  alStar : unitEnc = al unitEnc unitEncStar
  alStarAl: unitEnc' = alStar.1
  alStarP: P alStarAl = alStar.2
  goal : Path unitEnc (al unitEnc unitEncStar) z
    = pathSig2 A P alStar z (q,t) where
    A : U = unitEnc'

    -- proposition 2.4.5
    qq (X: U) (x: X): Path X (alStarAl X x) (al X x) = funExtInv unitEnc X ff gg pp unitEncStar where
      f: unitEnc -> X = unitEncRec X x
      ff : unitEnc -> X = o unitEnc unitEnc X f (al unitEnc)
      gg : unitEnc -> X = o unitEnc X X (al X) f
      pInst : U = Path (unitEnc -> X) ff gg where
        f: unitEnc -> X = unitEncRec X x
      pp : pInst = p unitEnc X (unitEncRec X x)

    qqEta (X: U): Path (X -> X) (alStarAl X) (al X) = funExtNonDep X X (alStarAl X) (al X) (qq X)

    q: Path unitEnc' alStar.1 al = funExt U (\(X: U) -> X -> X) alStarAl al qqEta
    t : PathP (<i> P (q @ i)) alStarP p = undefined
  P (X: U): U = isSet X -> X -> X
-}
