module coproduct_set where

import proto
import path
import iso
import propset
import proto_sigma

unitEnc' : U = (X: U) -> isSet X -> X -> X

unitEnc : U
  = (al : unitEnc') * ((X Y: U) -> (proofX: isSet X) -> (proofY: isSet Y) -> (f: X -> Y) ->
    Path (X -> Y) (o X X Y f (al X proofX)) (o X Y Y (al Y proofY) f))

unitEncStar : unitEnc = (\(X: U) (proofX: isSet X) -> idfun X, \(X Y: U) (proofX: isSet X) (proofY: isSet Y)-> refl (X -> Y))

unitEncRec (C: U) (proofC: isSet C) (c: C): unitEnc -> C
  = \(z: unitEnc) -> z.1 C proofC c

-- lemma 2.4.3
unitEncBeta (C: U) (proofC: isSet C) (c: C): Path C (unitEncRec C proofC c unitEncStar) c = refl C c

-- lemma 2.4.4 preliminaries (implicit in the paper)
proofUnitEnc: isSet unitEnc = undefined

upPath (X Y: U) (f: X -> Y) (al : X -> X): X -> Y = o X X Y f al
downPath (X Y: U) (f: X -> Y) (be: Y -> Y): X -> Y = o X Y Y be f

propUnitEncCondition (X Y: U) (proofX: isSet X) (proofY: isSet Y) (al' : (A: U) (proofA: isSet A) -> A -> A)
  : isProp ((f: X -> Y) -> Path (X -> Y) (upPath X Y f (al' X proofX)) (downPath X Y f (al' Y proofY)))
   = lem2 where
  PP (f: X -> Y): U = Path (X -> Y) (upPath X Y f (al' X proofX)) (downPath X Y f (al' Y proofY))

  lem1 (f: X -> Y): isProp (PP f)
    = setFun X Y proofY (upPath X Y f (al' X proofX)) (downPath X Y f (al' Y proofY))
  lem2
    : isProp           ((f: X -> Y) -> PP f)
    = propPi (X -> Y) (\(f: X -> Y) -> PP f) lem1

-- lemma 2.4.4
unitEncWeakEta (z: unitEnc): Path unitEnc (z.1 unitEnc proofUnitEnc unitEncStar) z = goal where
  P (al: (X : U) (proofX: isSet X) ->  X -> X): U = ((X Y: U) -> (proofX: isSet X) -> (proofY: isSet Y) -> (f: X -> Y) ->
    Path (X -> Y) (o X X Y f (al X proofX)) (o X Y Y (al Y proofY) f))
  al : unitEnc' = z.1
  p :  P al = z.2

  alStar : unitEnc = al unitEnc proofUnitEnc unitEncStar
  alStarAl: unitEnc' = alStar.1
  alStarP: P alStarAl = alStar.2

  -- proposition 2.4.5
  q: Path unitEnc' alStarAl al = funExt U (\(X: U) -> isSet X -> X -> X) alStarAl al qqEtaEta where
    qq (X: U) (proofX: isSet X) (x: X): Path X (alStarAl X proofX x) (al X proofX x)
      = funExtInv unitEnc X ff gg pp unitEncStar where

      f: unitEnc -> X = unitEncRec X proofX x
      ff : unitEnc -> X = o unitEnc unitEnc X f (al unitEnc proofUnitEnc)
      gg : unitEnc -> X = o unitEnc X X (al X proofX) f
      pInst : U = Path (unitEnc -> X) ff gg where
        f: unitEnc -> X = unitEncRec X proofX x
      pp : pInst = p unitEnc X proofUnitEnc proofX (unitEncRec X proofX x)

    qqEta (X: U) (proofX: isSet X): Path (X -> X) (alStarAl X proofX) (al X proofX)
      = funExtNonDep X X (alStarAl X proofX) (al X proofX) (qq X proofX)

    qqEtaEta (X: U): Path (isSet X -> X -> X) (alStarAl X) (al X)
      = funExtNonDep (isSet X) (X -> X) (alStarAl X) (al X) (qqEta X)

  p' : Path U (P alStar.1) (P z.1) = mapOnPath unitEnc' U P alStar.1 z.1 q
  t: Path (P z.1) (transport p' alStar.2) p = proofP (transport p' alStarP) p where
    proofP : isProp (P al) = undefined
  goal : Path unitEnc (al unitEnc proofUnitEnc unitEncStar) z
    = pathSig3 unitEnc' P alStar z (q,t) where
