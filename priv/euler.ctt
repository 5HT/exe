{- Homotopy Groups:
   - Homotopy Groups of Spheres;
   - Loop Space of S1 equals to Z.
   Copyright (c) Groupoid Infinity, 2016-2018 -}

module euler where
import s1
import trunc
import pointed
import suspension

-- Definition. Homotopy Groups of Spheres : \pi_{n}S^{m} = ||\Omega^{n}(S^{m})||_0
piS (n: nat): nat -> U = split
   zero   -> sTrunc (space (omega n (bool,false)))
   succ x -> sTrunc (space (omega n (Sn (succ x),north)))

-- Theorem. Loop Space of S1 equals to Z : \Omega^{1}(S^{1}) = Z
encode (x:S1) (p:Path S1 base x)
  : helix x
  = subst S1 helix base x p zeroZ

decode : (x:S1) -> helix x -> Path S1 base x = split
  base -> loopIt
  loop @ i -> rem @ i where
    T : U = Z -> loopS1
    G (x:S1) : U =  Path S1 base x
    p : Path U T T = <j> helix (loop1@j) -> Path S1 base (loop1@j)
    rem2 (n:Z) : Path loopS1 (oneTurn (loopIt n)) (loopIt (sucZ n)) = <i> lem1It n @ -i
    rem1 (n:Z) : Path loopS1 (subst S1 G base base loop1 (loopIt n)) (loopIt (subst S1 helix base base loop1 n))
      = comp (<i> Path loopS1 (oneTurn (loopIt n))
        (loopIt (testIsoPath Z Z sucZ predZ sucpredZ predsucZ n @ i))) (rem2 n) []
    rem : PathP p loopIt loopIt = corFib1 S1 helix G base loopIt loopIt loop1 rem1

-- helpers
ze    (x: nat):    bool -> Z         = split { false -> inl x      ; true -> inr x }
loopZ (x: nat):    bool -> loopS1    = split { false -> loopNeg x  ; true -> loopPos x }
turnZ (x: loopS1): bool -> loopS1    = split { false -> backTurn x ; true -> oneTurn x }
inversion:         bool -> loopS1    = split { false -> <i> loop1 @ -i ; true -> loop1 }
lnb   (n: nat) (b: bool):  loopS1    = loopZ n b
htl   (n: nat) (b: bool): Path U Z Z = <i> helix (turnZ (loopZ n b) b @ i)
hlx:               bool-> Path U Z Z = split { false -> <i>helix (loop1@-i) ; true -> <i>helix (loop1@i) }
htz   (n: nat) (b: bool):  Z         = comp (htl n b) (inr zero) []

lemTurn (n: nat): (b: bool) -> Path Z (comp (hlx b) (ze n b) []) (ze (succ n) b) = split
   false -> <i> inl (succ (comp (<_>nat) (comp (<_>nat) n [(i=1) -> <_>n]) [(i=1) -> <_>n]))
   true  -> <i> inr (succ (comp (<_>nat) (comp (<_>nat) n [(i=1) -> <_>n]) [(i=1) -> <_>n]))

-- section and retract
encodeNeg: (n: nat)-> Path Z (comp (<x> helix (loopZ n false @ x)) (inr zero) []) (ze n false) = split
  zero -> <_> (ze zero false)
  succ n -> (comp (<i> Path Z (htz n false) (lemTurn n false @ i))
            (comp (<i> Path Z (htz n false) (comp (hlx false) (encodeNeg n @ i) []))
                  (<i> lemFib2 S1 helix base base (lnb n false) (inr zero) base (inversion false) @ -i) []) [])

encodePos: (n: nat)-> Path Z (comp (<x> helix (loopZ n true @ x)) (inr zero) []) (ze n true) = split
  zero -> <_> (ze zero true)
  succ n -> (comp (<i> Path Z (htz n true) (lemTurn n true @ i))
            (comp (<i> Path Z (htz n true) (comp (hlx true) (encodePos n @ i) []))
                  (<i> lemFib2 S1 helix base base (lnb n true) (inr zero) base (inversion true) @ -i) []) [])

-- TODO: error
retractZ' (b: bool): (n: nat) -> Path Z (comp (<x> helix (loopZ n b @ x)) (inr zero) []) (ze n b) = split
  zero -> <_> (ze zero b)
  succ n -> (comp (<i> Path Z (htz n b) (lemTurn n b @ i))
            (comp (<i> Path Z (htz n b) (comp (hlx b) (retractZ' b n @ i) []))
                  (<i> lemFib2 S1 helix base base (lnb n b) (inr zero) base (inversion b) @ -i) []) [])

retractZ : (n : Z) -> Path Z (encode base (decode base n)) n = split
  inl n -> encodeNeg n
  inr n -> encodePos n

sectionZ (p: Path S1 base base) : Path (Path S1 base base) (decode base (encode base p)) p
  = comp (<i>Path (Path S1 base (p@i)) (decode (p@i) (encode (p@i) (<j>p@(i/\j)))) (<j>p@(i/\j)))
         (refl loopS1 triv) []

loopS1eqZ : Path U Z loopS1
  = isoPath Z loopS1 (decode base) (encode base) sectionZ retractZ

