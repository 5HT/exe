module hopf where
import iso
import circle
import suspension
S2 : U = susp S1
S3 : U = susp S2

fextToHE  (A B : U) (f g : A -> B) (p : Path (A -> B) f g) (e1 : isEquiv A B f) (e2 : isEquiv A B g)
        : PathP (<x> isEquiv A B (p @ x)) e1 e2
        = J (A -> B) f (\ (g : A -> B)
          (p: Path (A->B) f g)->(e1: isEquiv A B f)(e2: isEquiv A B g)->PathP (<x>isEquiv A B (p@x)) e1 e2)
          (\(e1: isEquiv A B f) (e2: isEquiv A B f) -> propIsEquiv A B f e1 e2) g p e1 e2

rotLoop : PathP (<i>isEquiv S1 S1 (rot (loop1@i))) (idIsEquiv S1) (idIsEquiv S1)
        = <x>fextToHE S1 S1 (idfun S1) (idfun S1) (<i>rot (loop{S1}@i)) (idIsEquiv S1) (idIsEquiv S1) @ x

rotIsEquiv: (a: S1) -> isEquiv S1 S1 (rot a) = split { base -> idIsEquiv S1; loop@x -> rotLoop@x }
rotpath (x: S1): Path U S1 S1 = equivPath S1 S1 (rot x) (rotIsEquiv x)

-- Hopf fibration
H : S2 -> U = split { north -> S1; south -> S1; merid a @ x -> rotpath a@x }

-- total space of H
TH : U = (c : S2) * H c

