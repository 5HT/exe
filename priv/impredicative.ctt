module impredicative where
import proto
import path

{- Impredicative Encoding of Inductive Types in HoTT:
   [1]. https://github.com/sspeight93/Papers/
   [2]. https://homotopytypetheory.org/2017/10/11/impredicative-encodings-of-inductive-types-in-hott/
   [3]. https://www.newton.ac.uk/files/seminar/20170711090010001-1009680.pdf
-}

upPath (X Y: U) (f: X -> Y) (al : X -> X): X -> Y = o X X Y f al
downPath (X Y: U) (f: X -> Y) (be: Y -> Y): X -> Y = o X Y Y be f
naturality (X Y: U) (al: X -> X) (be: Y -> Y) (f: X -> Y): U
  = Path (X -> Y) (upPath X Y f al) (downPath X Y f be)

unitEnc': U = (X: U) -> isSet X -> X -> X
isUnitEnc (one: unitEnc'): U
   = (X Y: U)
  -> (x: isSet X)
  -> (y: isSet Y)
  -> (f: X -> Y)
  -> naturality X Y (one X x) (one Y y) f

unitEnc: U = (x: unitEnc') * isUnitEnc x
unitEncStar: unitEnc = (\(X:U)(_:isSet X)->idfun X,\(X Y: U)(_:isSet X)(_:isSet Y)->refl(X->Y))
unitEncRec  (C: U) (s: isSet C) (c: C): unitEnc -> C = \(z: unitEnc) -> z.1 C s c
unitEncBeta (C: U) (s: isSet C) (c: C): Path C (unitEncRec C s c unitEncStar) c = refl C c
unitEncEta (z: unitEnc): Path unitEnc unitEncStar z = undefined
unitEncInd (P: unitEnc -> U) (a: unitEnc): P unitEncStar -> P a = subst unitEnc P unitEncStar a (unitEncEta a)
unitEncCondition (n: unitEnc'): isProp (isUnitEnc n)
  =  \ (f g: isUnitEnc n) -> <h> \ (x y: U) -> \ (X: isSet x) -> \ (Y: isSet y)
  -> \ (F: x -> y) -> <i> \ (R: x) -> Y (F (n x X R)) (n y Y (F R))
       (<j> f x y X Y F @ j R) (<j> g x y X Y F @ j R) @ h @ i

endoEnc' : U = (X: U) -> isSet X -> (X -> X) -> X -> X
isEndoEnc (one: endoEnc'): U
   = (X Y: U)
  -> (x: isSet X)
  -> (y: isSet Y)
  -> (f: X -> Y)
  -> (c: X -> X)
  -> (d: Y -> Y)
  -> naturality X Y (one X x c) (one Y y d) f

endoEnc: U = (x: endoEnc') * isEndoEnc x
