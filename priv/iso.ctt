module iso where

import propset
import path

isContr (A : U) : U = (x : A) * ((y : A) -> Path A x y)

lemPropF (A : U) (P : A -> U) (pP : (x : A) -> isProp (P x)) (a0 a1 :A)
         (p : Path A a0 a1) (b0 : P a0) (b1 : P a1) : PathP (<i>P (p@i)) b0 b1 =
 <i>pP (p@i) (comp (<j>P (p@i/\j)) b0 [(i=0) -> <_>b0]) (comp (<j>P (p@i\/-j)) b1 [(i=1) -> <_>b1])@i

-- other proof
-- lemPropF (A : U) (P : A -> U) (pP : (x : A) -> prop (P x)) (a :A) :
--          (a1 : A) (p : Path A a a1) (b0 : P a) (b1 : P a1) -> PathP (<i>P (p@i)) b0 b1 =
-- J A a (\ (a1 : A) (p : Path A a a1) ->
--          (b0 : P a) (b1 : P a1) -> PathP (<i>P (p@i)) b0 b1)
--   rem
-- where rem : (b0 b1:P a) -> Path (P a) b0 b1 = pP a

lemSig (A : U) (B : A -> U) (pB : (x : A) -> isProp (B x))
       (u v : (x:A) * B x) (p : Path A u.1 v.1) :
       Path ((x:A) * B x) u v =
  <i> (p@i,(lemPropF A B pB u.1 v.1 p u.2 v.2)@i)

propSig (A : U) (B : A -> U) (pA : isProp A)
        (pB : (x : A) -> isProp (B x)) (t u : (x:A) * B x) :
        Path ((x:A) * B x) t u =
  lemSig A B pB t u (pA t.1 u.1)

lemProp (A : U) (h : A -> isProp A) : isProp A =
  \(a : A) -> h a a

propIsContr (A : U) : isProp (isContr A) = lemProp (isContr A) rem
  where
    rem (t : isContr A) : isProp (isContr A) = propSig A T pA pB
      where
        T (x : A) : U = (y : A) -> Path A x y
        pA (x y : A) : Path A x y = composition A x t.1 y (<i> t.2 x @ -i) (t.2 y)
        pB (x : A) : isProp (T x) =
          propPi A (\ (y : A) -> Path A x y) (propSet A pA x)

--         u
--    a0 -----> a1
--    |         |
-- r0 |         | r1
--    |         |
--    V         V
--    b0 -----> b1
--         v
Square (A : U) (a0 a1 b0 b1 : A)
               (u : Path A a0 a1) (v : Path A b0 b1)
               (r0 : Path A a0 b0) (r1 : Path A a1 b1) : U
  = PathP (<i> (PathP (<j> A) (u @ i) (v @ i))) r0 r1

fiber (A B : U) (f : A -> B) (y : B) : U =
  (x : A) * Path B y (f x)

isEquiv (A B : U) (f : A -> B) : U = (y : B) -> isContr (fiber A B f y)

equiv (A B : U) : U = (f : A -> B) * isEquiv A B f

propIsEquiv (A B : U) (f : A -> B)
  : isProp (isEquiv A B f) =
  \ (u0 u1:isEquiv A B f) ->
     <i> \ (y:B) -> propIsContr (fiber A B f y) (u0 y) (u1 y) @ i

idIsEquiv (A : U) : isEquiv A A (idfun A) =
  \(a : A) -> ((a, refl A a)
              ,\(z : fiber A A (idfun A) a) -> contrSingl A a z.1 z.2)

lemSinglContr (A:U) (a:A) : isContr ((x:A) * Path A a x) =
 ((a,refl A a),\ (z:(x:A) * Path A a x) -> contrSingl A a z.1 z.2)

idEquiv (A:U) : equiv A A = (\ (x:A) -> x, lemSinglContr A)

-- The iso to equiv
lemIso (A B : U) (f : A -> B) (g : B -> A)
       (s : (y : B) -> Path B (f (g y)) y)
       (t : (x : A) -> Path A (g (f x)) x)
       (y : B) (x0 x1 : A) (p0 : Path B y (f x0)) (p1 : Path B y (f x1)) :
       Path (fiber A B f y) (x0,p0) (x1,p1) = <i> (p @ i,sq1 @ i)
  where
    rem0 : Path A (g y) x0 =
      <i> comp (<k> A) (g (p0 @ i)) [ (i = 1) -> t x0, (i = 0) -> <k> g y ]

    rem1 : Path A (g y) x1 =
      <i> comp (<k> A) (g (p1 @ i)) [ (i = 1) -> t x1, (i = 0) -> <k> g y ]

    p : Path A x0 x1 =
     <i> comp (<k> A) (g y) [ (i = 0) -> rem0
                            , (i = 1) -> rem1 ]

    fill0 : Square A (g y) (g (f x0)) (g y) x0
                     (<i> g (p0 @ i)) rem0 (<i> g y) (t x0)  =
      <i j> comp (<k> A) (g (p0 @ i)) [ (i = 1) -> <k> t x0 @ j /\ k
                                      , (i = 0) -> <k> g y
                                      , (j = 0) -> <k> g (p0 @ i) ]

    fill1 : Square A (g y) (g (f x1)) (g y) x1
                     (<i> g (p1 @ i)) rem1 (<i> g y) (t x1) =
      <i j> comp (<k> A) (g (p1 @ i)) [ (i = 1) -> <k> t x1 @ j /\ k
                                      , (i = 0) -> <k> g y
                                      , (j = 0) -> <k> g (p1 @ i) ]

    fill2 : Square A (g y) (g y) x0 x1
                     (<k> g y) p rem0 rem1 =
      <i j> comp (<k> A) (g y) [ (i = 0) -> <k> rem0 @ j /\ k
                               , (i = 1) -> <k> rem1 @ j /\ k
                               , (j = 0) -> <k> g y ]

    sq : Square A (g y) (g y) (g (f x0)) (g (f x1))
                  (<i> g y) (<i> g (f (p @ i)))
                  (<j> g (p0 @ j)) (<j> g (p1 @ j)) =
      <i j> comp (<k> A) (fill2 @ i @ j) [ (i = 0) -> <k> fill0 @ j @ -k
                                         , (i = 1) -> <k> fill1 @ j @ -k
                                         , (j = 0) -> <k> g y
                                         , (j = 1) -> <k> t (p @ i) @ -k ]

    sq1 : Square B y y (f x0) (f x1)
                   (<k>y) (<i> f (p @ i)) p0 p1 =
      <i j> comp (<k> B) (f (sq @ i @j)) [ (i = 0) -> s (p0 @ j)
                                         , (i = 1) -> s (p1 @ j)
                                         , (j = 1) -> s (f (p @ i))
                                         , (j = 0) -> s y ]

isoToEquiv (A B : U) (f : A -> B) (g : B -> A)
       (s : (y : B) -> Path B (f (g y)) y)
       (t : (x : A) -> Path A (g (f x)) x) : isEquiv A B f =
  \(y:B) -> ((g y,<i>s y@-i),\ (z:fiber A B f y) ->
    lemIso A B f g s t y (g y) z.1 (<i>s y@-i) z.2)

isoPath (A B : U) (f : A -> B) (g : B -> A)
      (s : (y : B) -> Path B (f (g y)) y)
      (t : (x : A) -> Path A (g (f x)) x) : Path U A B =
       <i> Glue B [ (i = 0) -> (A,f,isoToEquiv A B f g s t)
                  , (i = 1) -> (B,idfun B,idIsEquiv B) ]

pathSig (A:U) (B : A -> U) (t u : Sigma A B) :
 Path U (Path (Sigma A B) t u) ((p : Path A t.1 u.1) * PathP (<i> B (p @ i)) t.2 u.2) =
  isoPath T0 T1 f g s t where
   T0 : U = Path (Sigma A B) t u
   T1 : U = (p:Path A t.1 u.1) * PathP (<i> B (p@i)) t.2 u.2
   f (q:T0) : T1 = (<i> (q@i).1,<i> (q@i).2)
   g (z:T1) : T0 = <i>(z.1 @i,z.2 @i)
   s (z:T1) : Path T1 (f (g z)) z = refl T1 z
   t (q:T0) : Path T0 (g (f q)) q = refl T0 q

pathSig2 (A:U) (P : A -> U) (t u : Sigma A P) (pp: (p : Path A t.1 u.1) * PathP (<i> P (p @ i)) t.2 u.2): Path (Sigma A P) t u
  = comp (<i> pathSig A P t u @ -i) pp []

pathAnd (A B : U) (t u : and A B) :
  Path U (Path (and A B) t u) (and (Path A t.1 u.1) (Path B t.2 u.2)) = pathSig A (\(_ : A) -> B) t u
