module k_theory where
import algebra
import equiv
import bishop
import swaptrans
import iso_sigma



-- commuative monoids and groups
op  (m: cmonoid): m.1.1 -> m.1.1 -> m.1.1 = opCMonoid m
op3 (m: cmonoid): m.1.1 -> m.1.1 -> m.1.1 -> m.1.1 = \ (a b c : m.1.1) -> op m a (op m b c)
asc (m: cmonoid): isAssociative m.1.1 (op m) = isAssocCMonoid m
id  (m: cmonoid): m.1.1 = idCMonoid m
hid (m: cmonoid): hasIdentity m.1.1 (op m) (id m) = hasIdCMonoid m
cm  (m: cmonoid): isCommutative m.1.1 (op m) = isCommCMonoid m
ac  (m: cmonoid): AscCom = (m.1.1, op m, asc m, cm m)
gac (g: abgroup): AscCom = (g.1.1, opCGroup g, isAssocCGroup g, isCommCGroup g)

-- Direct product of a cancellative monoid with appropriate operators and properties
pair (m : cmonoid): U = prod m.1.1 m.1.1
pset (m : cmonoid): isSet (pair m) = setSig m.1.1 (\(_ : m.1.1) -> m.1.1) m.1.2 (\(_ : m.1.1) -> m.1.2)
pop  (m : cmonoid) (x y : pair m) : pair m = (op m x.1 y.1, op m x.2 y.2)
pid (m : cmonoid) : pair m = (id m, id m)
phid (m : cmonoid) : hasIdentity (pair m) (pop m) (pid m)
  = (\ (x : pair m) -> <i> ((hid m).1 x.1 @ i, (hid m).1 x.2 @ i),
     \ (x : pair m) -> <i> ((hid m).2 x.1 @ i, (hid m).2 x.2 @ i))
pasc (m : cmonoid) : isAssociative (pair m) (pop m)
  = \ (x0 x1 x2 : pair m) -> <i> (asc m x0.1 x1.1 x2.1 @ i, asc m x0.2 x1.2 x2.2 @ i)
pcm (m : cmonoid) : isCommutative (pair m) (pop m)
  = \ (x0 x1 : pair m) -> <i> (cm m x0.1 x1.1 @ i, cm m x0.2 x1.2 @ i)

-- Equivalence relation on pair
prel (m: cmonoid) (a b : pair m): PROP
  = exists m.1.1 (\(t: m.1.1) -> Path m.1.1 (op3 m t a.1 b.2) (op3 m t b.1 a.2))

prelisrefl (m : cmonoid) (a : pair m) : (prel m a a).1 -- exists m.1.1 T pT
  = let
    T (k: m.1.1) : U = Path m.1.1 (op3 m k a.1 a.2) (op3 m k a.1 a.2)
    k: m.1.1 = id m
  in existspr m.1.1 T k (<i> op m (id m) (op m a.1 a.2))

prelissymm (m : cmonoid) (a b : pair m) (p0 : (prel m a b).1) : (prel m b a).1
  = let
    T0 (t : m.1.1) : U = Path m.1.1 (op3 m t a.1 b.2) (op3 m t b.1 a.2)
    T1 (t : m.1.1) : U = Path m.1.1 (op3 m t b.1 a.2) (op3 m t a.1 b.2)
    f (k : m.1.1) (p : T0 k) : (exists m.1.1 T1).1 = existspr m.1.1 T1 k (<i> p @ -i)
    P : PROP = exists m.1.1 T1
  in existsel m.1.1 T0 (exists m.1.1 T1) f p0

existsel2 (A : U) (B : A -> U) (C : U) (D : C -> U)
    (P: PROP) (f : (x : A) (_ : B x) (y : C) (_ : D y) -> P.1)
    (e0 : (exists A B).1) (e1 : (exists C D).1) : P.1
  = let
    T0 : U = (c : C) (d : D c) -> P.1
    pT0 : isProp T0 = propPi C (\(c : C) -> (D c) -> P.1)
          (\(c : C) -> propPi (D c) (\(_ : D c) -> P.1) (\(_ : D c) -> P.2))
  in existsel C D P (existsel A B (T0, pT0) f e0) e1

prelistrans (m : cmonoid) (x y z : pair m) (p0 : (prel m x y).1) (p1 : (prel m y z).1)
  : (prel m x z).1
  = let
    T0 (k : m.1.1) : U = Path m.1.1 (op3 m k x.1 y.2) (op3 m k y.1 x.2)
    T1 (k : m.1.1) : U = Path m.1.1 (op3 m k y.1 z.2) (op3 m k z.1 y.2)
    T2 (k : m.1.1) : U = Path m.1.1 (op3 m k x.1 z.2) (op3 m k z.1 x.2)
    f (k : m.1.1) (p0 : T0 k) (l : m.1.1) (p1 : T1 l) : (exists m.1.1 T2).1
      = existspr m.1.1 T2 (op m k (op m l y.2)) (swptrans (ac m) k l (x.1, x.2) (y.1, y.2) (z.1, z.2) p0 p1)
  in existsel2 m.1.1 T0 m.1.1 T1 (exists m.1.1 T2) f p0 p1

-- quotients
setquot (X: U) (R: hrel X): U = (A : hsubtypes X) * (iseqclass X R A)

setsetquot (X : U) (R : hrel X) : isSet (setquot X R) =
  setSig (hsubtypes X) (\(A : hsubtypes X) -> iseqclass X R A)
    sA sB
    where
    sA : isSet (hsubtypes X) = sethsubtypes X
    sB (x : hsubtypes X) : isSet (iseqclass X R x) = propSet (iseqclass X R x) (propiseqclass X R x)

setquotpr (X : U) (R : eqrel X) (X0 : X) : setquot X R.1 = (A,((p1,p2),p3))
   where
   rax : isrefl X R.1 = eqrelrefl X R
   sax : issymm X R.1 = eqrelsymm X R
   tax : istrans X R.1 = eqreltrans X R
   A : hsubtypes X = \(x : X) -> R.1 X0 x
   p1 : (ishinh (carrier X A)).1 = hinhpr (carrier X A) (X0,rax X0)
   p2 (x1 x2 : X) (X1 : (R.1 x1 x2).1) (X2 : (A x1).1) : (A x2).1 = tax X0 x1 x2 X2 X1
   p3 (x1 x2 : X) (X1 : (A x1).1) (X2 : (A x2).1) : (R.1 x1 x2).1 = tax x1 X0 x2 (sax X0 x1 X1) X2

peqrel (m: cmonoid) : eqrel (pair m) = (prel m, ((prelistrans m, prelisrefl m), prelissymm m))

-- If f respects R then all x belonging to the equivalence class C are mapped into the same unique image
setquotmapcontr (A B : U) (sB : isSet B) (R : hrel A) (f : A -> B)
    (frr : funresprel A B f R) (C : setquot A R)
  : isContr ((y : B) * ((x : carrier A C.1) -> Path B y (f x.1)))
  = let
    T : U = (y : B) * ((x : carrier A C.1) -> Path B y (f x.1))
    pT (a b : T) : Path T a b
      = let
        h (x : carrier A C.1) : Path B a.1 b.1 = <i> comp (<j> B) (a.2 x @ i)
          [ (i = 0) -> <j> a.1
          , (i = 1) -> <j> b.2 x @ -j ]
        p0 : Path B a.1 b.1
          = C.2.1.1 (Path B a.1 b.1, sB a.1 b.1) h
        p1 : PathP (<i> (x : carrier A C.1) -> Path B (p0 @ i) (f x.1)) a.2 b.2
          = let
            P (b : B) : U
              = (x : carrier A C.1) -> Path B b (f x.1)
            pP (b : B) (s t : (P b)) : Path (P b) s t
              = <i>  \ (x : carrier A C.1) -> (sB b (f x.1) (s x) (t x)) @ i
          in lemPropF B P pP a.1 b.1 p0 a.2 b.2
      in <i> (p0 @ i, p1 @ i)
    h (x : carrier A C.1) : T
      = (f x.1, \ (x' : carrier A C.1) -> frr x.1 x'.1 (C.2.2 x.1 x'.1 x.2 x'.2))
    y : T
      = C.2.1.1 (T, pT) h
  in (y, pT y)

setquotmap (A B : U) (sB : isSet B) (R : hrel A) (f : A -> B)
    (frr : funresprel A B f R) (c : setquot A R) : B
  = (setquotmapcontr A B sB R f frr c).1.1

setquotmapeq (A B : U) (sB : isSet B) (R : eqrel A) (f : A -> B)
    (frr : funresprel A B f R.1) (x : A)
  : Path B (setquotmap A B sB R.1 f frr (setquotpr A R x)) (f x)
  = (setquotmapcontr A B sB R.1 f frr (setquotpr A R x)).1.2 (x, R.2.1.2 x)

iseqclasspair (A B : U) (R0 : hrel A) (R1 : hrel B) (H0 : hsubtypes A)
    (H1 : hsubtypes B) (E0 : iseqclass A R0 H0) (E1 : iseqclass B R1 H1)
  : iseqclass (prod A B) (hrelpair A B R0 R1) (hsubtypespair A B H0 H1)
  = let
    H : hsubtypes (prod A B) = hsubtypespair A B H0 H1
    a (P : PROP) (f : carrier (prod A B) H -> P.1) : P.1
      = let
        g (x0 : carrier A H0) : P.1 = let h (x1 : carrier B H1) : P.1 = f ((x0.1, x1.1), (x0.2, x1.2)) in E1.1.1 P h
      in E0.1.1 P g
    b (x0 x1 : prod A B) (r : (hrelpair A B R0 R1 x0 x1).1) (h0 : (H x0).1) : (H x1).1
      = (E0.1.2 x0.1 x1.1 r.1 h0.1, E1.1.2 x0.2 x1.2 r.2 h0.2)
    c (x0 x1 : prod A B) (h0 : (H x0).1) (h1 : (H x1).1) : (hrelpair A B R0 R1 x0 x1).1
      = (E0.2 x0.1 x1.1 h0.1 h1.1, E1.2 x0.2 x1.2 h0.2 h1.2)
  in ((a, b), c)

setquotpair (A B : U) (R0 : hrel A) (R1 : hrel B) (q0 : setquot A R0)
    (q1 : setquot B R1)
  : setquot (prod A B) (hrelpair A B R0 R1)
  = ( hsubtypespair A B q0.1 q1.1
    , iseqclasspair A B R0 R1 q0.1 q1.1 q0.2 q1.2)


setquotmap2 (A B C : U) (sC : isSet C) (R0 : hrel A) (R1 : hrel B)
    (f : A -> B -> C) (frr : funresprel2 A B C f R0 R1) (c0 : setquot A R0)
    (c1 : setquot B R1) : C
  = let
    f' (t : prod A B) : C = f t.1 t.2
    R' : hrel (prod A B) = hrelpair A B R0 R1
    frr' (s t : prod A B) (r : (R' s t).1) : Path C (f' s) (f' t) = frr s.1 t.1 s.2 t.2 r.1 r.2
    c' : setquot (prod A B) R' = setquotpair A B R0 R1 c0 c1
  in setquotmap (prod A B) C sC R' f' frr' c'

setquotmapeq2 (A B C : U) (sC : isSet C) (R0 : eqrel A) (R1 : eqrel B)
    (f : A -> B -> C) (frr : funresprel2 A B C f R0.1 R1.1) (x0: A) (x1 : B)
  : Path C (setquotmap2 A B C sC R0.1 R1.1 f frr (setquotpr A R0 x0) (setquotpr B R1 x1)) (f x0 x1)
  = let
    f' (t : prod A B) : C = f t.1 t.2
    R : eqrel (prod A B) = eqrelpair A B R0 R1
    frr' (s t : prod A B) (r : (R.1 s t).1) : Path C (f' s) (f' t) = frr s.1 t.1 s.2 t.2 r.1 r.2
  in setquotmapeq (prod A B) C sC R f' frr' (x0, x1)

isEquivprop (A B : U) (f : A -> B) (g : B -> A) (pA : isProp A) (pB : isProp B) : isEquiv A B f = rem
  where
  rem (y : B) : isContr (fiber A B f y) = (s,t)
    where
    s : fiber A B f y = (g y,pB y (f (g y)))
    t (w : fiber A B f y) : Path ((x :  A) * Path B y (f x)) s w =
      subtypeEquality A (\(x : A) -> Path B y (f x)) pb s w r1
       where
       pb (x : A) : (a b : Path B y (f x)) -> Path (Path B y (f x)) a b = propSet B pB y (f x)
       r1 : Path A s.1 w.1 = pA s.1 w.1

equivhProp (P P' : PROP) (f : P.1 -> P'.1) (g : P'.1 -> P.1) : equiv P.1 P'.1 =
  (f,isEquivprop P.1 P'.1 f g P.2 P'.2)

uahp' (P P' : PROP) (f : P.1 -> P'.1) (g : P'.1 -> P.1) : Path PROP P P' =
  subtypeEquality U isProp propIsProp P P' rem
  where
  rem : Path U P.1 P'.1 = transport (<i> corrUniv P.1 P'.1 @ -i) (equivhProp P P' f g)

iscompsetquotpr (X : U) (R : eqrel X) (x x' : X) (a : (R.1 x x').1) :
  Path (setquot X R.1) (setquotpr X R x) (setquotpr X R x') =
  subtypeEquality (hsubtypes X) (iseqclass X R.1) rem1 (setquotpr X R x) (setquotpr X R x') rem2
  where
  rem1 (x : hsubtypes X) : isProp (iseqclass X R.1 x) = propiseqclass X R.1 x
  rem2 : Path (hsubtypes X) (setquotpr X R x).1 (setquotpr X R x').1 =
    <i> \(x0 : X) -> rem x0 @ i
    where
    rem (x0 : X) : Path PROP (R.1 x x0) (R.1 x' x0) = uahp' (R.1 x x0) (R.1 x' x0) f g
      where
      f (r0 : (R.1 x x0).1) : (R.1 x' x0).1 = eqreltrans X R x' x x0 (eqrelsymm X R x x' a) r0
      g (r0 : (R.1 x' x0).1) : (R.1 x x0).1 = eqreltrans X R x x' x0 a r0

qgroup    (m: cmonoid): U = setquot (pair m) (prel m)
setqgroup (m: cmonoid): isSet (qgroup m)     = setsetquot (pair m) (prel m)
qpr       (m: cmonoid) (x: pair m): qgroup m = setquotpr (pair m) (peqrel m) x
qid       (m: cmonoid) : qgroup m = qpr m (pid m)
qop'      (m: cmonoid) (x0 x1: pair m): qgroup m = qpr m (pop m x0 x1)
qinv'     (m: cmonoid) (x0 : pair m) : qgroup m = qpr m (x0.2, x0.1)

qinv'resprel (m : cmonoid) (x y : pair m) (r : (prel m x y).1)
  : Path (qgroup m) (qinv' m x) (qinv' m y)
  = let
    T0 (k : m.1.1) : U
      = Path m.1.1 (op3 m k x.1 y.2) (op3 m k y.1 x.2)
    T1 (k : m.1.1) : U
      = Path m.1.1 (op3 m k x.2 y.1) (op3 m k y.2 x.1)
    f (k : m.1.1) (p : T0 k) : (exists m.1.1 T1).1
      = existspr m.1.1 T1 k (<i> comp (<_> m.1.1) (p @ -i)
        [ (i = 0) -> <j> op m k (cm m y.1 x.2 @ j)
        , (i = 1) -> <j> op m k (cm m x.1 y.2 @ j) ])
  in iscompsetquotpr (pair m) (peqrel m) (x.2, x.1) (y.2, y.1)
       (existsel m.1.1 T0 (exists m.1.1 T1) f r)

qop'resprel (m : cmonoid) (x x' y y' : pair m) (p0 : (prel m x x').1)
    (p1 : (prel m y y').1) : Path (qgroup m) (qop' m x y) (qop' m x' y')
  = let
    z0 : pair m = pop m x y
    z1 : pair m = pop m x' y'
    T0 (k : m.1.1) : U = Path m.1.1 (op3 m k x.1 x'.2) (op3 m k x'.1 x.2)
    T1 (k : m.1.1) : U = Path m.1.1 (op3 m k y.1 y'.2) (op3 m k y'.1 y.2)
    T2 (k : m.1.1) : U = Path m.1.1 (op3 m k z0.1 z1.2) (op3 m k z1.1 z0.2)
    T3 : U = Path (qgroup m) (qop' m x y) (qop' m x' y')
    pT3 : isProp T3 = setqgroup m (qop' m x y) (qop' m x' y')
    f (k : m.1.1) (p0 : T0 k) (l : m.1.1) (p1 : T1 l) : T3
      = let
        n : m.1.1 = op m k l
        p : Path m.1.1 (op3 m n z0.1 z1.2) (op3 m n z1.1 z0.2)
          = <i> comp (<_> m.1.1) (op m (p0 @ i) (p1 @ i))
            [ (i = 0) -> <j> comp (<_> m.1.1) (swp8 (ac m) k (op m x.1 x'.2) l (op m y.1 y'.2) @ j)
              [ (j = 0) -> <_> (op m (op3 m k x.1 x'.2) (op3 m l y.1 y'.2))
              , (j = 1) -> <h> op m (op m k l) (swp8 (ac m) x.1 x'.2 y.1 y'.2 @ h) ]
            , (i = 1) -> <j> comp (<_> m.1.1) (swp8 (ac m) k (op m x'.1 x.2) l (op m y'.1 y.2) @ j)
              [ (j = 0) -> <_> (op m (op3 m k x'.1 x.2) (op3 m l y'.1 y.2))
              , (j = 1) -> <h> op m (op m k l) (swp8 (ac m) x'.1 x.2 y'.1 y.2 @ h) ]]
        e : (prel m z0 z1).1 = existspr m.1.1 T2 n p
      in iscompsetquotpr (pair m) (peqrel m) z0 z1 e
  in existsel2 m.1.1 T0 m.1.1 T1 (T3, pT3) f p0 p1

qinv (m : cmonoid) (q : qgroup m) : qgroup m
  = setquotmap (pair m) (qgroup m) (setqgroup m) (prel m) (qinv' m)
      (qinv'resprel m) q

qinveq (m : cmonoid) (x : pair m) : Path (qgroup m) (qinv m (qpr m x)) (qinv' m x)
  = setquotmapeq (pair m) (qgroup m) (setqgroup m) (peqrel m)
      (qinv' m) (qinv'resprel m) x

qop       (m: cmonoid) (q0 q1: qgroup m): qgroup m
  = setquotmap2 (pair m) (pair m) (qgroup m) (setqgroup m) (prel m)
      (prel m) (qop' m) (qop'resprel m) q0 q1

eqax0 (X : U) (R : hrel X) (A : hsubtypes X) (eqc : iseqclass X R A) : (ishinh (carrier X A)).1 = eqc.1.1
eqax1 (X : U) (R : hrel X) (A : hsubtypes X) (eqc : iseqclass X R A) : (x1 x2 : X) -> (R x1 x2).1 -> (A x1).1 -> (A x2).1 = eqc.1.2
eqax2 (X : U) (R : hrel X) (A : hsubtypes X) (eqc : iseqclass X R A) : (x1 x2 : X) -> (A x1).1 -> (A x2).1 -> (R x1 x2).1 = eqc.2

setquotl0 (X : U) (R : eqrel X) (c : setquot X R.1) (x : carrier X c.1) :
  Path (setquot X R.1) (setquotpr X R x.1) c = subtypeEquality (hsubtypes X) (iseqclass X R.1) p (setquotpr X R x.1) c rem where
  p (A : hsubtypes X) : isProp (iseqclass X R.1 A) = propiseqclass X R.1 A
  rem : Path (hsubtypes X) (setquotpr X R x.1).1 c.1 = <i> \(x : X) -> (rem' x) @ i -- inlined use of funext
    where rem' (a : X) : Path PROP ((setquotpr X R x.1).1 a) (c.1 a) =
            uahp' ((setquotpr X R x.1).1 a) (c.1 a) l2r r2l   -- This is where uahp appears
              where
              l2r (r : ((setquotpr X R x.1).1 a).1) : (c.1 a).1 = eqax1 X R.1 c.1 c.2 x.1 a r x.2
              r2l : (c.1 a).1 -> ((setquotpr X R x.1).1 a).1 = eqax2 X R.1 c.1 c.2 x.1 a x.2

setquotunivprop (X : U) (R : eqrel X) (P : setquot X R.1 -> PROP)
  (ps : (x : X) -> (P (setquotpr X R x)).1) (c : setquot X R.1) : (P c).1 = hinhuniv (carrier X c.1) (P c) f rem
  where
   f (x : carrier X c.1) : (P c).1 =
     let e : Path (setquot X R.1) (setquotpr X R x.1) c = setquotl0 X R c x
     in subst (setquot X R.1) (\(w : setquot X R.1) -> (P w).1) (setquotpr X R x.1) c e (ps x.1)
   rem : (ishinh (carrier X c.1)).1 = eqax0 X R.1 c.1 c.2

setquotuniv2prop (X : U) (R : eqrel X) (P : setquot X R.1 -> setquot X R.1 -> PROP)
  (ps : (x x' : X) -> (P (setquotpr X R x) (setquotpr X R x')).1) (c c' : setquot X R.1) : (P c c').1 =
    setquotunivprop X R (\ (c0' : setquot X R.1) -> P c c0')
      (\ (x : X) -> setquotunivprop X R (\ (c0 : setquot X R.1) -> P c0 (setquotpr X R x))
                      (\ (x0 : X) -> ps x0 x) c) c'

setquotuniv3prop (X : U) (R : eqrel X)
    (P : setquot X R.1 -> setquot X R.1 -> setquot X R.1 -> PROP)
    (ps : (x0 x1 x2 : X) -> (P (setquotpr X R x0) (setquotpr X R x1) (setquotpr X R x2)).1)
    (q0 q1 q2 : setquot X R.1) : (P q0 q1 q2).1
  = setquotunivprop X R (P q0 q1) (\(x2' : X) -> setquotunivprop X R (\ (q1' : setquot X R.1) -> P q0 q1' (setquotpr X R x2'))
          (\(x1' : X) ->  setquotunivprop X R (\(q0' : setquot X R.1) -> P q0' (setquotpr X R x1')
              (setquotpr X R x2')) (\(x0' : X) -> ps x0' x1' x2') q0) q1) q2

qopeq (m : cmonoid) (x0 x1 : pair m)
  : Path (qgroup m) (qop m (qpr m x0) (qpr m x1)) (qop' m x0 x1)
  = setquotmapeq2 (pair m) (pair m) (qgroup m) (setqgroup m) (peqrel m)
      (peqrel m) (qop' m) (qop'resprel m) x0 x1

opaque qinv'resprel
opaque qinveq
opaque setquot
opaque qopeq
opaque qop'resprel
opaque setqgroup
opaque setquotpr
opaque setquotl0
opaque setquotunivprop
opaque setquotuniv2prop
opaque setquotuniv3prop
opaque setsetquot
opaque iscompsetquotpr
opaque setquotmap
opaque setquotmap2
opaque setquotmapeq
opaque setquotmapeq2

qasc (m : cmonoid) : isAssociative (qgroup m) (qop m)
  = \ (q0 q1 q2 : qgroup m) ->
  let
    tP (x0 x1 x2 : qgroup m) : U
      = Path (qgroup m) (qop m x0 (qop m x1 x2)) (qop m (qop m x0 x1) x2)
    ps (x0 x1 x2 : pair m) : tP (qpr m x0) (qpr m x1) (qpr m x2)
      = let
        p0 : Path (qgroup m) (qop m (qpr m x0) (qop m (qpr m x1) (qpr m x2)))
                         (qpr m (pop m x0 (pop m x1 x2)))
          = <i> comp (<_> qgroup m) (qop m (qpr m x0) (qopeq m x1 x2 @ i))
            [ (i = 0) -> <_> qop m (qpr m x0) (qop m (qpr m x1) (qpr m x2))
            , (i = 1) -> qopeq m x0 (pop m x1 x2) ]
        p1 : Path (qgroup m) (qpr m (pop m x0 (pop m x1 x2)))
                         (qpr m (pop m (pop m x0 x1) x2))
          = <i> qpr m (pasc m x0 x1 x2 @ i)
        p2 : Path (qgroup m) (qop m (qop m (qpr m x0) (qpr m x1)) (qpr m x2))
                         (qpr m (pop m (pop m x0 x1) x2))
          = <i> comp (<_> qgroup m) (qop m (qopeq m x0 x1 @ i) (qpr m x2))
            [ (i = 0) -> <_> qop m (qop m (qpr m x0) (qpr m x1)) (qpr m x2)
            , (i = 1) -> qopeq m (pop m x0 x1) x2 ]
      in <i> comp (<_> qgroup m) (p1 @ i)
        [ (i = 0) -> <j> p0 @ -j
        , (i = 1) -> <j> p2 @ -j ]
    pP (x0 x1 x2 : qgroup m) : isProp (tP x0 x1 x2)
      = setqgroup m (qop m x0 (qop m x1 x2)) (qop m (qop m x0 x1) x2)
    P (x0 x1 x2 : qgroup m) : PROP
      = (tP x0 x1 x2, pP x0 x1 x2)
  in setquotuniv3prop (pair m) (peqrel m) P ps q0 q1 q2

qlid (m : cmonoid) : hasLeftIdentity (qgroup m) (qop m) (qid m)
  = \ (q : qgroup m) -> let
    tP (x : qgroup m) : U
      = Path (qgroup m) (qop m (qid m) x) x
    ps (x : pair m) : tP (qpr m x)
      = let
        p0 : Path (qgroup m) (qop m (qid m) (qpr m x)) (qop' m (pid m) x) = qopeq m (pid m) x
        p1 : Path (qgroup m) (qop' m (pid m) x) (qpr m x) = <i> qpr m ((phid m).1 x @ i)
      in <i> comp (<_> qgroup m) (p0 @ i)
        [ (i = 0) -> <_> p0 @ 0
        , (i = 1) -> p1 ]
    pP (x : qgroup m) : isProp (tP x) = setqgroup m (qop m (qid m) x) x
    P (x : qgroup m) : PROP = (tP x, pP x)
  in setquotunivprop (pair m) (peqrel m) P ps q

qrid (m : cmonoid) : hasRightIdentity (qgroup m) (qop m) (qid m)
  = \ (q : qgroup m) -> let
    tP (x : qgroup m) : U = Path (qgroup m) (qop m x (qid m)) x
    ps (x : pair m) : tP (qpr m x) 
      = let
        p0 : Path (qgroup m) (qop m (qpr m x) (qid m)) (qop' m x (pid m)) = qopeq m x (pid m)
        p1 : Path (qgroup m) (qop' m x (pid m)) (qpr m x) = <i> qpr m ((phid m).2 x @ i)
      in <i> comp (<_> qgroup m) (p0 @ i)
        [ (i = 0) -> <_> p0 @ 0
        , (i = 1) -> p1 ]
    pP (x : qgroup m) : isProp (tP x) = setqgroup m (qop m x (qid m)) x
    P (x : qgroup m) : PROP = (tP x, pP x)
  in setquotunivprop (pair m) (peqrel m) P ps q


qhli (m : cmonoid) : hasLeftInverse (qgroup m) (qop m) (qid m) (qinv m)
  = \ (q : qgroup m) -> let
    tP (x : qgroup m) : U = Path (qgroup m) (qop m (qinv m x) x) (qid m)
    ps (x : pair m) : tP (qpr m x)
      = let
        T (k : m.1.1) : U
          = Path m.1.1 (op m k (op m (op m x.2 x.1) (id m)))
                     (op m k (op m (id m) (op m x.1 x.2)))
        p0 : Path (qgroup m) (qop m (qinv m (qpr m x)) (qpr m x)) (qop' m (x.2, x.1) x)
          = <i> comp (<_> qgroup m) (qop m (qinveq m x @ i) (qpr m x)) 
            [ (i = 0) -> <_> qop m (qinv m (qpr m x)) (qpr m x)
            , (i = 1) -> qopeq m (x.2, x.1) x ]
        p1 : Path m.1.1 (op m (id m) (op m (op m x.2 x.1) (id m)))
                      (op m (id m) (op m (id m) (op m x.1 x.2)))
          = <i> op m (id m) (comp (<j> m.1.1) (cm m (op m x.2 x.1) (id m) @ i)
              [ (i = 0) -> <j> (op m (op m x.2 x.1) (id m))
              , (i = 1) -> <j> op m (id m) (cm m x.2 x.1 @ j) ])
        p2 : Path (qgroup m) (qop' m (x.2, x.1) x) (qid m)
          = iscompsetquotpr (pair m) (peqrel m) (pop m (x.2, x.1) x) (pid m)
              (existspr m.1.1 T (id m) p1)
      in <i> comp (<_> qgroup m) (p0 @ i)
        [ (i = 0) -> <_> p0 @ 0
        , (i = 1) -> p2 ]
    pP (x : qgroup m) : isProp (tP x)
      = setqgroup m (qop m (qinv m x) x) (qid m)
    P (x : qgroup m) : PROP
      = (tP x, pP x)
  in setquotunivprop (pair m) (peqrel m) P ps q

qhri (m : cmonoid) : hasRightInverse (qgroup m) (qop m) (qid m) (qinv m)
  = \ (q : qgroup m) -> let
    tP (x : qgroup m) : U = Path (qgroup m) (qop m x (qinv m x)) (qid m)
    ps (x : pair m) : tP (qpr m x)
      = let
        T (k : m.1.1) : U
          = Path m.1.1 (op m k (op m (op m x.1 x.2) (id m)))
                     (op m k (op m (id m) (op m x.2 x.1)))
        p0 : Path (qgroup m) (qop m (qpr m x) (qinv m (qpr m x))) (qop' m x (x.2, x.1))
          = <i> comp (<_> qgroup m) (qop m (qpr m x) (qinveq m x @ i))
            [ (i = 0) -> <_> qop m (qpr m x) (qinv m (qpr m x))
            , (i = 1) -> qopeq m x (x.2, x.1) ]
        p1 : Path m.1.1 (op m (id m) (op m (op m x.1 x.2) (id m)))
                      (op m (id m) (op m (id m) (op m x.2 x.1)))
          = <i> op m (id m) (comp (<j> m.1.1) (cm m (op m x.1 x.2) (id m) @ i)
              [ (i = 0) -> <j> (op m (op m x.1 x.2) (id m))
              , (i = 1) -> <j> op m (id m) (cm m x.1 x.2 @ j) ])
        p2 : Path (qgroup m) (qop' m x (x.2, x.1)) (qid m)
          = iscompsetquotpr (pair m) (peqrel m) (pop m x (x.2, x.1)) (pid m)
              (existspr m.1.1 T (id m) p1)
      in <i> comp (<_> qgroup m) (p0 @ i)
        [ (i = 0) -> <_> p0 @ 0
        , (i = 1) -> p2 ]
    pP (x : qgroup m) : isProp (tP x)
      = setqgroup m (qop m x (qinv m x)) (qid m)
    P (x : qgroup m) : PROP
      = (tP x, pP x)
  in setquotunivprop (pair m) (peqrel m) P ps q

qc (m : cmonoid) : isCommutative (qgroup m) (qop m)
  = \ (q0 q1 : qgroup m) -> let
    tP (x0 x1 : qgroup m) : U
      = Path (qgroup m) (qop m x0 x1) (qop m x1 x0)
    ps (x0 x1 : pair m) : tP (qpr m x0) (qpr m x1)
      = <i> comp (<_> qgroup m) (qpr m (pcm m x0 x1 @ i))
        [ (i = 0) -> <j> qopeq m x0 x1 @ -j
        , (i = 1) -> <j> qopeq m x1 x0 @ -j ]
    pP (x0 x1 : qgroup m) : isProp (tP x0 x1)
      = setqgroup m (qop m x0 x1) (qop m x1 x0)
    P (x0 x1 : qgroup m) : PROP
      = (tP x0 x1, pP x0 x1)
  in setquotuniv2prop (pair m) (peqrel m) P ps q0 q1

grothendieck (m: cmonoid): abgroup
  = ((qgroup m, setqgroup m),(((qop m,qasc m,qid m,(qlid m,qrid m)),qinv m,(qhli m, qhri m)),qc m))
