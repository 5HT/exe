module lambek where

import functor
import control
import either
import nat

data tuple (A B: U) = pair (a: A) (b: B)

fst (A B: U): tuple A B -> A = split pair a b -> a

snd (A B: U): tuple A B -> B = split pair a b -> b

cata (A: U) (F: U -> U) (X: functor F) (alg: F A -> A) (f: fix F): A
  = alg (X.1 (fix F) A (cata A F X alg) (out_ F f))

ana (A: U) (F: U -> U) (X: functor F) (coalg: A -> F A) (a: A): fix F
  = Fix (X.1 A (fix F) (ana A F X coalg) (coalg a))

hylo (A B: U) (F: U -> U) (X: functor F) (alg: F B -> B) (coalg: A -> F A) (a: A): B
  = alg (X.1 A B (hylo A B F X alg coalg) (coalg a))

para (A: U) (F: U -> U) (X: functor F) (alg: F (tuple (fix F) A) -> A) (f: fix F): A
  = alg (X.1 (fix F) (tuple (fix F) A) (\(m: fix F) -> pair m (para A F X alg m)) (out_ F f))

zygo (A B: U) (F: U -> U) (X: functor F) (g: F A -> A) (alg: F (tuple A B) -> B) (f: fix F): B
  = snd A B (cata (tuple A B) F X (\(x: F (tuple A B))
    -> pair (g (X.1 (tuple A B) A (\(y: tuple A B) -> fst A B y) x)) (alg x)) f)

prepro (A: U) (F: U -> U) (X: functor F) (nt: F(fix F) -> F(fix F)) (alg: F A -> A) (f: fix F): A
  = alg (X.1 (fix F) A (\(x: fix F) -> prepro A F X nt alg (cata (fix F) F X (\(y: F(fix F))
    -> Fix (nt y)) x)) (out_ F f))

postpro (A: U) (F: U -> U) (X: functor F) (nt : F(fix F) -> F(fix F)) (coalg: A -> F A) (a: A): fix F
  = Fix (X.1 A (fix F) (\(x: A) -> ana (fix F) F X (\(y: fix F)
    -> nt (out_ F y)) (postpro A F X nt coalg x)) (coalg a))

apo (A: U) (F: U -> U) (X: functor F) (coalg: A -> F(either (fix F) A)) (a: A): fix F
  = Fix (X.1 (either (fix F) A) (fix F) (\(x: either (fix F) A)
    -> either_ (fix F) A (fix F) (idfun (fix F)) (apo A F X coalg) x) (coalg a))

gapo (A B: U) (F: U -> U) (X: functor F) (coalg: A -> F A) (coalg2: B -> F(either A B)) (b: B): fix F
  = Fix ((X.1 (either A B) (fix F) (\(x: either A B)
    -> either_ A B (fix F) (\(y: A) -> ana A F X coalg y) (\(z: B)
    -> gapo A B F X coalg coalg2 z) x) (coalg2 b)))

futu (A: U) (F: U -> U) (X: functor F) (f: A -> F (free F A)) (a: A): fix F =
  Fix (X.1 (free F A) (fix F) (\(z: free F A) -> w z) (f a)) where
  w: free F A -> fix F = split
    Free x -> unpack x where
  unpack_free: freeF F A (fix (freeF F A)) -> fix F = split
    ReturnF x -> futu A F X f x
    BindF g -> Fix (X.1 (fix (freeF F A)) (fix F) (\(x: fix (freeF F A)) -> w (Free x)) g)
  unpack: fix (freeF F A) -> fix F = split
    Fix x -> unpack_free x

histo (A:U) (F: U->U) (X: functor F) (f: F (cofree F A) -> A) (z: fix F): A =
  extract A F ((cata (cofree F A) F X (\(x: F (cofree F A)) ->
    CoFree (Fix (CoBindF (f x) ((X.1 (cofree F A)
    (fix (cofreeF F A)) (uncofree A F) x)))))) z) where
  extract (A: U) (F: U -> U): cofree F A -> A = split
    CoFree f -> unpack_fix f where
  unpack_fix: fix (cofreeF F A) -> A = split
    Fix f -> unpack_cofree f where
  unpack_cofree: cofreeF F A (fix (cofreeF F A)) -> A = split
    CoBindF a -> a

chrono (A B: U) (F: U -> U) (X: functor F)
       (f: F (cofree F B) -> B)
       (g: A -> F (free F A))
       (a: A): B = histo B F X f (futu A F X g a)

mcata (T: U) (F: U -> U) (phi: ((fix F) -> T) -> F (fix F) -> T) (t: fix F): T
    = phi (\(x: fix F) -> mcata T F phi x) (out_ F t)

meta  (A B: U) (F: U -> U) (X: functor F)
      (f: A -> F A) (e: B -> A)
      (g: F B -> B) (t: fix F): fix F
    = ana A F X f (e (cata B F X g t))

mutu (A B: U) (F: U -> U) (X: functor F)
     (f: F (tuple A B) -> B)
     (g: F (tuple B A) -> A)
     (t: fix F): A
   = g (X.1 (fix F) (tuple B A) (\(x: fix F) ->
     pair (mutu B A F X g f x) (mutu A B F X f g x)) (out_ F t))

-- inductive types

ind (A: U) (F: U -> U): U
    = (in_: F (fix F) -> fix F)
    * (in_rev: fix F -> F (fix F))
    * (fold_: (F A -> A) -> fix F -> A)
    * Unit

inductive (F: U -> U) (A: U) (X: functor F): ind A F
    = (in_ F,out_ F,cata A F X,tt)

coind (A: U) (F: U -> U): U
    = (out_: fix F -> F (fix F))
    * (out_rev: F (fix F) -> fix F)
    * (unfold_: (A -> F A) -> A -> fix F)
    * Unit

coinductive (F: U -> U) (A: U) (X: functor F): coind A F
    = (out_ F,in_ F,ana A F X,tt)

-- category of F-algebra endofunctors

listAlg (A : U) : U
    = (X: U)
    * (nil: X)
    * (cons: A -> X -> X)
    * Unit

listMor (A: U) (x1 x2: listAlg A) : U
    = (map: x1.1 -> x2.1)
    * (mapNil: Path x2.1 (map (x1.2.1)) (x2.2.1))
    * (mapCons: (a:A) (x: x1.1) -> Path x2.1 (map (x1.2.2.1 a x)) (x2.2.2.1 a (map x)))
    * Unit

listObject (A: U) : U
    = (point: (x: listAlg A) -> x.1)
    * (map: (x1 x2: listAlg A)
            (m: listMor A x1 x2) ->
            Path x2.1 (m.1 (point x1)) (point x2))
    * Unit

listCategory (A: U) (o: listObject A): U = undefined

-- Finite Sets
data Fin (n: nat)
    = fzero
    | fsuc (n: nat) (i: Fin (pred n))

-- Inductive Types
data Type
    = var
    | one
    | sigma (S: U) (T: S -> Type)
    | pi    (S: U) (T: S -> Type)

-- Inductive Families
data Family (I: U)
    = ivar (i: I)
    | ione
    | isum (n: nat) (T: Fin n -> Family I)
    | isigma (S: U) (T: S     -> Family I)
    | ipi    (S: U) (T: S     -> Family I)

-- Interpret Types
i (X: U): Type -> U = split
   var       -> X
   one       -> Unit
   sigma S T -> (s: S) *  i X (T s)
   pi    S T -> (s: S) -> i X (T s)

ii (I: U) (X: I -> U): Family I -> U = split
   ivar   i   -> X i
   ione       -> Unit
   isum   n T -> (k: Fin n) * ii I X (T k)
   isigma S T -> (s: S)     * ii I X (T s)
   ipi    S T -> (s: S)    -> ii I X (T s)

-- Canonical Lifting
lift (X: U) (P: X -> U) : (D: Type) (xs: i X D) -> U = split
   var       -> \(xs: i X (var)) -> P xs
   one       -> \(xs: i X (one)) -> Unit
   sigma S T -> \(xs: i X (sigma S T))        -> lift X P (T xs.1) xs.2
   pi S T    -> \(xs: i X (pi S T)) -> (s: S) -> lift X P (T s) (xs s)

ilift (I: U) (X: I -> U) (P: (i: I) -> X i -> U): (D: Family I) -> (xs: ii I X D) -> U = split
   ivar i     -> \(xs: ii I X (ivar i)) -> X i
   ione       -> \(xs: ii I X (ione)) -> Unit
   isum n T   -> \(xs: ii I X (isum n T))   -> ilift I X P (T xs.1) xs.2
   isigma S T -> \(xs: ii I X (isigma S T)) -> ilift I X P (T xs.1) xs.2
   ipi S T    -> \(xs: ii I X (ipi S T))    -> (s: S) -> ilift I X P (T s) (xs s)

-- Mu
data Mu (D: Type) = mu (x: i (Mu D) D)

DAlg (D: Type) (P: Mu D -> U) (xs: i (Mu D) D): U = lift (Mu D) P D xs -> P (mu xs)

