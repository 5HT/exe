module list_theory where

{- list type-class instances and theorems -}

import proto
import list
import control
import functor
import nat_theory

eq_list_nat:               eq                   = (list nat,        list_eq eq_nat)
eq_list_list_nat:          eq                   = (list (list nat), list_eq eq_list_nat)
pure_list          (A: U): pure          A list = (\(x: A) -> cons x nil, tt)
functor_list     (A B: U): functor_    A B list = (map A B,         tt)

x : list (maybe nat) = (functor_list nat (maybe nat)).1 (\(x: nat) -> just zero) nil
pure_list_nat: pure nat list = (\(x: nat) -> cons one nil, tt)
y : list nat = pure_list_nat.1 one

-- tests/usage

-- let b : nat = foldr nat nat (\(x : nat) (y : nat) -> add x y) one (cons zero nil) in b
-- let a : list nat = append nat nil nil in a
-- filter nat f (cons zero (cons n1 (cons n2 (cons n3 (cons zero nil)))))

data S = O | P | C
opc : list S = cons O (cons P (cons C nil))
cpo : list S = cons C (cons P (cons O nil))

-- theorems

assoc (A:U) : (xs ys zs : list A) ->
  Path (list A) (append A (append A xs ys) zs) (append A xs (append A ys zs)) = split
  nil -> \ (ys zs:list A) -> <i>append A ys zs
  cons x xs -> \ (ys zs:list A) -> <i>cons x (assoc A xs ys zs@i)

lem (A B C:U) (f:A->B) (g:B -> C) : (xs:list A) ->
  Path (list C) (map B C g (map A B f xs)) (map A C (\ (x:A) -> g (f x)) xs) = split
  nil -> <i>nil
  cons x xs -> <i>cons (g (f x)) (lem A B C f g xs@i)

lem1 (A:U) : (xs:list A) -> Path (list A) (map A A (idfun A) xs) xs = split
  nil -> <i>nil
  cons x xs -> <i>cons x (lem1 A xs@i)

lem2 (A:U) : (xs:list A) -> Path (list A) (append A xs nil) xs = split
  nil -> <i>nil
  cons x xs -> <i>cons x (lem2 A xs@i)
