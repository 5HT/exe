module om where

import list
import control

data alg = z | o | max (a b: alg) | min (a b: alg) | app (a b: alg)
name: U = list nat

data pts
    = star             (n: nat)
    | var    (x: name) (l: nat)
    | pi     (x: name) (l: nat) (d c: pts)
    | lambda (x: name) (l: nat) (d c: pts)
    | app                       (f a: pts)

shift (v: name) (n: nat): pts -> pts = split
    star x           -> star x
    var x l           -> var x l -- error yet
    pi x l i o         -> pi x l (shift v n i) (shift v (suc n) o)
    lambda x l i o -> lambda x l (shift v n i) (shift v (suc n) o)
    app f a           -> app f a

subst (n: name) (v: pts) (i: nat): pts -> pts = split
    star x           -> star x
    var x i             -> v -- error yet
    pi x l i o         -> pi x l (subst n v l i) (subst n (shift x zero v) (suc l) o)
    lambda x l i o -> lambda x l (subst n v l i) (subst n (shift x zero v) (suc l) o)
    app f a           -> app f a

mutual
  subst_on_fun (a: pts): pts -> pts = split
    star x         -> app (star x) (norm a)
    var x i        -> app (var x i) (norm a)
    pi x l i o     -> app (pi x l i o) (norm a)
    lambda x l i o -> norm (subst x o l a)
    app f a        -> app (app f a) (norm a)
  norm: pts -> pts = split
    star x           -> star x
    var x i           -> var x i
    pi x l i o         -> pi x l (norm i) (norm o)
    lambda x l i o -> lambda x l (norm i) (norm o)
    app f a           -> subst_on_fun a (norm f)

data exists
    = sigma (n: name) (a b: exists)
    | pair (a b: exists)
    | fst (p: exists)
    | snd (p: exists)

data identity
    = id (a b: identity)
    | idpair (a b: identity)
    | idelim (a b c d e: identity)

data tele (A: U)   = emp | tel (n: name) (b: A) (t: tele A)
data branch (A: U) =          br (n: name) (args: list name) (term: A)
data label (A: U)  =         lab (n: name) (t: tele A)

data ind
    = data_  (n: name) (t: tele ind) (labels:   list (label ind))
    | case   (n: name) (t: ind)      (branches: list (branch ind))
    | ctor   (n: name)               (args:     list ind)

list_str: name = cons n1 nil
a_str:    name = cons n2 nil
nil_str:  name = cons n3 nil
cons_str: name = cons n4 nil
x_str:    name = cons n5 nil
xs_str:   name = cons n6 nil
{-
program:  p  = data_                      -- data
                 list_str                   -- list
                 (tel a_str (star one) emp) -- (a: U) =
                (cons (lab nil_str emp)     -- nil |
                (cons (lab cons_str
                      (tel x_str  (var a_str zero) -- cons (x: A) (xs: list A)
                      (tel xs_str (ctor list_str (cons (var a_str zero)
                                                  nil)) emp)))
                 nil))
-}


-- refine type

--var (l: name): list (Sigma name ind) -> bool = undefined
sh:    ind -> name -> nat -> ind             = undefined
subst: ind -> name -> ind -> ind             = undefined
norm:  ind -> ind                            = undefined
equ:   ind -> bool                           = undefined
--type:  ind -> list (Sigma name ind) -> ind   = undefined

data hts
    = path (a b: hts)
    | path_lam (n: name) (a b: hts)
    | path_app (f: name) (a b: hts)
    | comp_ (a b: hts)
    | fill_ (a b c: hts)
    | glue_ (a b c: hts)
    | glue_elem (a b: hts)
    | unglue_elem (a b: hts)
