{- Path Type:
   Copyright (c) Groupoid Infinity, 2014-2018.

   see HoTT 1.12 Identity types
   see HoTT 1.12.1 Path induction
   see HoTT 2.1 Types are higher groupoids
   see HoTT 2.11 Identity type
   see HoTT 3.11 Contractibility
   see HoTT 6.2 Induction principles and dependent paths. -}

module path where

import proto_path

isConst (A: U) (f: A -> A): U = (x y: A) -> Path A (f x) (f y)

exConst (A: U): U = (f: A -> A) * isConst A f

mapOnPath (A B: U) (f: A -> B) (a b: A) (p: Path A a b): Path B (f a) (f b)
--  = cong A B f a b p
    = <i> f (p @ i)

subst (A: U) (P: A -> U) (a b: A) (p: Path A a b) (e: P a): P b
    = comp (<i> P (p @ i)) e [] -- normal form
--  = trans (P a) (P b) (mapOnPath A U P a b p) e

substInv (A: U) (P: A -> U) (a b: A) (p: Path A a b): P b -> P a
    = subst A P b a (<i> p @ -i)

transRefl (A: U) (a: A): Path A (transport (<_> A) a) a
    = <i> comp (<_> A) a [(i=1) -> <_>a]

substPathP (A B: U) (p: Path U A B) (x: A) (y: B) (q: Path B (transport p x) y): PathP p x y
    = transport (<i> PathP p x (q@i)) (<i> comp (<j> p @ (i /\ j)) x [(i=0) -> <_> x])

-- J is formulated in a form of Paulin-Mohring and implemented
-- using two facts that singleton are contractible and dependent function transport.
JPM (A: U) (a b: A) (P: singl A a -> U) (u: P (eta A a)) (p: Path A a b): P (b,p)
    = subst (singl A a) T (eta A a) (b,p) (contr A a b p) u where T (z : singl A a) : U = P z

data N = Z  | S (n: N)

-- n-Groupoid
n_grpd (A: U) (n: N): U = (a b: A) -> rec A a b n where
   rec (A: U) (a b: A) : (k: N) -> U
     = split { Z -> Path A a b ; S n -> n_grpd (Path A a b) n }

isContr     (A: U): U = (x: A) * ((y: A) -> Path A x y)
isProp      (A: U): U = n_grpd A Z
isSet       (A: U): U = n_grpd A (S Z)
isGroupoid  (A: U): U = n_grpd A (S (S Z))
isGrp2      (A: U): U = n_grpd A (S (S (S Z)))
isGrp3      (A: U): U = n_grpd A (S (S (S (S Z))))

-- âˆž-Groupoid
inf_grpd (A: U): U
  = (carrier: A)
  * (eq: (a b: A) -> Path A a b)
  * ((a b: A) -> inf_grpd (Path A a b))

isInfinityGroupoid (A: U): U = inf_grpd A

-- h-Types
PROP         : U = (X:U) * isProp X
SET          : U = (X:U) * isSet X
GROUPOID     : U = (X:U) * isGroupoid X
INF_GROUPOID : U = (X:U) * isInfinityGroupoid X

-- if there's a path from a type then there is a path from every element
elemPathP (A B: U) (p: Path U A B) (a: A): (p': Path U A B) * (b: B) * PathP p' a b
  = comp (<i> P (p @ i)) (refl U A, a, refl A a) [] where
  P (X: U): U = (p: Path U A X) * (x: X) * PathP p a x

