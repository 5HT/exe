-- Characterization of equality in pi types.
module pi_prev where

import list
import iso_pi

pi (A:U) (P:A->U) : U = (x:A) -> P x

-- logic framework

Pi (A: U) : U
    = (intro: (A -> U) -> U)
    * (lambda: (B: A -> U) -> pi A B -> intro B)
    * (app:    (B: A -> U) -> intro B -> pi A B)
    * (applam: (B: A -> U) (f: pi A B) -> (a: A) -> Path (B a) ((app B (lambda B f)) a) (f a))
    * (lamapp: (B: A -> U) (p: intro B) -> Path (intro B) (lambda B (\(a:A) -> app B p a)) p)
    * Unit

intro (A:U):(A->U)->U = \(x:A->U)->list A
--lambda (A:U) (B:A->U):pi A B->intro B=\(x:A->U)(y:pi A B)->singl B
--app (A: U) (B: A -> U): U = intro B -> pi A B


-- todo: prove applam lamapp

groupoidPi (A:U) (B:A -> U) (h:(x:A) -> groupoid (B x)) (f g:pi A B) : set (Path (pi A B) f g) =
    subst U set  T  (Path (pi A B) f g) (<i>pathPi A B f g@-i) rem1
 where
  T : U = (x:A) -> Path (B x) (f x) (g x)
  rem1 : set T =  setPi A (\ (x:A) -> Path (B x) (f x) (g x)) (\ (x:A) -> h x (f x) (g x))

propPi2 (A : U) (B0 : A -> A -> U) (h0 : (x y : A) -> prop (B0 x y))
  : prop ((x y : A) -> B0 x y)
  = let
    p0 (a : A) : prop ((b : A) -> B0 a b)
      = propPi A (B0 a) (h0 a)
    B1 (a : A) : U
      = (b : A) -> B0 a b
  in propPi A B1 p0

propPi3 (A : U) (B0 : A -> A -> A -> U) (h0 : (x y z : A) -> prop (B0 x y z))
  : prop ((x y z : A) -> B0 x y z)
  = let
    p0 (a b : A) : prop ((c : A) -> B0 a b c)
      = propPi A (B0 a b) (h0 a b)
    B1 (a b : A) : U
      = (c : A) -> B0 a b c
  in propPi2 A B1 p0


