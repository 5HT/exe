{- Prop Module:
   - Prop Theorems;
   Copyright (c) Groupoid Infinity, 2014-2018.

   see HoTT 3.3 Mere propositions
-}

module prop where

import proto
import path

discrete (A: U): U = (a b: A) -> dec (Path A a b)

propUnit : isProp unit = split
 tt -> split@((x:unit) -> Path unit tt x) with
  tt -> <i> tt

-- Exists(A,B) = ||Sigma(A,B)||

lemPropF (A : U) (P : A -> U) (pP : (x : A) -> isProp (P x)) (a0 a1 :A)
         (p : Path A a0 a1) (b0 : P a0) (b1 : P a1) : PathP (<i>P (p@i)) b0 b1 =
 <i> pP (p@i) (comp (<j>P (p@i/\j)) b0 [(i=0) -> <_>b0])
              (comp (<j>P (p@i\/-j)) b1 [(i=1) -> <_>b1]) @ i

lemSig (A : U) (B : A -> U) (pB : (x : A) -> isProp (B x))
       (u v : (x:A) * B x) (p : Path A u.1 v.1) :
       Path ((x:A) * B x) u v =
  <i> (p@i,(lemPropF A B pB u.1 v.1 p u.2 v.2)@i)

propSig (A : U) (B : A -> U) (pA : isProp A)
        (pB : (x : A) -> isProp (B x)) (t u : (x:A) * B x) :
        Path ((x:A) * B x) t u =
  lemSig A B pB t u (pA t.1 u.1)

-- Forall(A,B) = ||Pi(A,B)||

propPi (A : U) (B: A -> U) (h: (x : A) -> isProp (B x)) (f0 f1: (x: A) -> B x) : Path ((x: A) -> B x) f0 f1
  = <i> \ (x:A) -> (h x (f0 x) (f1 x)) @ i

propPi2 (A: U) (B: A -> A -> U) (h: (x y: A) -> isProp (B x y)): isProp ((x y: A) -> B x y)
  = let p (a: A): isProp ((b: A) -> B a b) = propPi A (B a) (h a)
        B1 (a: A): U = (b: A) -> B a b
     in propPi A B1 p

propPi3 (A: U) (B: A -> A -> A -> U) (h: (x y z: A) -> isProp (B x y z)): isProp ((x y z: A) -> B x y z)
  = let p (a b: A): isProp ((c : A) -> B a b c) = propPi A (B a b) (h a b)
        B1 (a b: A): U = (c: A) -> B a b c
     in propPi2 A B1 p

---------

propN0 : isProp empty = \ (x y: empty) -> efq (Path empty x y) x

propNeg (A:U) : isProp (neg A) = \ (f g:neg A) -> <i>\(x:A) -> (propN0 (f x) (g x))@i

propOr (A B : U) (hA : isProp A) (hB : isProp B) (h : A -> neg B) : isProp (either A B) = split
    inl a' -> split@((b : either A B) -> Path (either A B) (inl a') b) with
        inl b' -> <i> inl (hA a' b' @ i)
        inr b' -> efq (Path (either A B) (inl a') (inr b')) (h a' b')
    inr a' -> split@((b : either A B) -> Path (either A B) (inr a') b) with
        inl b' -> efq (Path (either A B) (inr a') (inl b')) (h b' a')
        inr b' -> <i> inr (hB a' b' @ i)

propDec (A : U) (h : isProp A) : isProp (dec A) =
  propOr A (neg A) h (propNeg A) (\(x : A) (h : neg A) -> h x)

propAnd (A B : U) (pA : isProp A) (pB : isProp B) : isProp (prod A B) =
  propSig A (\(_ : A) -> B) pA (\(_ : A) -> pB)

---------

decEqCong (A B : U) (f : A -> B) (g : B -> A) : dec A -> dec B = split
  inl a -> inl (f a)
  inr h -> inr (\ (b:B) -> h (g b))

decStable (A:U) : dec A -> stable A = split
 inl a -> \ (h :neg (neg A)) -> a
 inr b -> \ (h :neg (neg A)) -> efq A (h b)

decConst (A : U) : dec A -> exConst A = split
  inl a -> (\ (x:A)  -> a, \ (x y:A) -> refl A a)
  inr h -> (\ (x:A) -> x, \ (x y:A) -> efq (Path A x y) (h x))

stableConst (A : U) (sA: stable A) : exConst A =
 (\ (x:A) -> sA (dneg A x),\ (x y:A) -> <i>sA (propNeg (neg A) (dneg A x) (dneg A y) @ i))

injective (A B : U) (f : A -> B) : U =
  (a0 a1 : A) -> Path B (f a0) (f a1) -> Path A a0 a1
