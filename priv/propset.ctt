-- propositions and sets
module propset where

import path
import proto

-- only for isProp/isSet
data N = Z | S (n: N)

mutual
  rec (A: U) (a b: A): (k: N) -> U = split
    Z -> Path A a b
    S n -> n_grpd (Path A a b) n
  n_grpd (A: U) (n: N): U = (a b: A) -> ((rec A a b) n)

isProp      (A: U): U = n_grpd A Z
isSet       (A: U): U = n_grpd A (S Z)

-- page 14
Set : U = (a: U) * isSet a

propSet (A : U) (h : isProp A) : isSet A =
 \(a b : A) (p q : Path A a b) ->
   <j i> comp (<_> A) a [ (i=0) -> h a a
                        , (i=1) -> h a b
                        , (j=0) -> h a (p @ i)
                        , (j=1) -> h a (q @ i)]

propUnit : isProp Unit = split
 tt -> split@((x:Unit) -> Path Unit tt x) with
  tt -> <i> tt

unitSet : Set = (Unit, propSet Unit propUnit)

setElem (S: Set): U = S.1

-- foo (S: Set) (e: setElem S): e -> e = idfun e

u : setElem unitSet = tt

obSet (A: Set): U = A.1
homSet (A B: Set): U = obSet A -> obSet B


foo : homSet unitSet unitSet = idfun Unit

propPi (A : U) (B : A -> U) (h : (x : A) -> isProp (B x))
       (f0 f1 : (x : A) -> B x) : Path ((x : A) -> B x) f0 f1
  = <i> \ (x:A) -> (h x (f0 x) (f1 x)) @ i

piExtPath (A: U) (B: A -> U) (f g: (x: A) -> B x)
  : Path U (Path ((x : A) -> B x) f g) ((x: A) -> Path (B x) (f x) (g x))
  = undefined

-- setPi - Sets are closed under pi-abstraction
-- Note that `A` is any type and not merely a set
-- Proof plan:
-- We expand `isSet` so we see it's underlying equality on paths.
-- Then we apply `propPi` to `h` to prove `isProp a` - an eta-expanded version
-- of the goal. Then we use pi-extensionality path between a and b to convert
-- isProp a to isProp b
setPi (A : U) (B : A -> U) (h : (x : A) -> isSet (B x)): isSet ((x: A) -> B x)
  = goal h where
  goal (h : (x : A)
    (g0 g1 :            B x) -> isProp (Path (           B x) g0 g1))
    (f  g  : (x : A) -> B x) :  isProp (Path ((x : A) -> B x) f g)
    = subst U isProp a b p e where
    a : U = (x: A) -> Path (B x) (f x) (g x)
    b : U = Path ((x : A) -> B x) f g
    p : Path U a b = <i> (piExtPath A B f g) @ -i
    e : isProp a = propPi A P (\(x: A) -> h x (f x) (g x)) where
      P (x: A): U = Path (B x) (f x) (g x)
