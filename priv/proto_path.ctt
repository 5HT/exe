module proto_path where

-- Path type
Path     (A: U) (a b: A): U = PathP (<i> A) a b
refl     (A: U) (a: A): Path A a a = <i> a
singl    (A: U) (a: A): U = (x : A) * Path A a x
trans  (A B: U) (p: Path U A B) (a : A): B = comp p a []
sym      (A: U) (a b: A) (p: Path A a b): Path A b a = <i> p @ -i
inv      (A: U) (a b: A) (p: Path A a b): Path A b a = <i> p @ -i
cong   (A B: U) (f: A -> B) (a b: A) (p: Path A a b): Path B (f a) (f b) = <i> f (p @ i)
const    (A: U) (f: A -> A): U = (x y: A) -> Path A (f x) (f y)
exConst  (A: U): U = (f: A -> A) * const A f

kan (A: U) (a b c d: A) (p: Path A a b)
    (q: Path A a c) (r: Path A b d): Path A c d =
    <i> comp (<j>A) (p @ i) [(i = 0) -> q,
                             (i = 1) -> r ]

mapOnPath (A B : U) (f : A -> B) (a b : A) (p : Path A a b) : Path B (f a) (f b)
    = <i> f (p @ i)

subst (A : U) (P : A -> U) (a b : A) (p : Path A a b) (e : P a) : P b
    = comp (<i> P (p @ i)) e []
--  = trans (P a) (P b) (mapOnPath A U P a b p) e

substInv (A : U) (P : A -> U) (a b : A) (p : Path A a b) : P b -> P a
    =  subst A P b a (<i> p @ -i)

composition (A : U) (a b c : A) (p : Path A a b) (q : Path A b c) : Path A a c
    = comp (<i> Path A a (q @ i)) p []
--  = subst A (Path A a) b c q p
--  = <i> comp (<j>A) (p @ i) [ (i = 1) -> q, (i=0) -> <j> a ]

eta (A:U)(a:A): singl A a = (a,refl A a)

contrSingl (A : U) (a b : A) (p : Path A a b) : Path (singl A a) (a,refl A a) (b,p)
    = <i> (p @ i,<j> p @ i/\j)

-- J is formulated in a form of Paulin-Mohring and implemented
-- using two facts that singleton are contractible and dependent function transport.
JPM (A: U) (a b: A) (P: singl A a -> U) (u: P (a,refl A a)) (p: Path A a b): P (b,p)
    = subst (singl A a) T (a,refl A a) (b,p) (contrSingl A a b p) u
    where T (z : singl A a) : U = P z

-- based path induction from HoTT book
J (A : U) (a : A) (C : (x : A) -> Path A a x -> U)
  (d : C a (refl A a)) (x : A) (p : Path A a x) : C x p = -- comp (<i> C (p @ i) (<j> p @ i /\ j)) d []
    subst (singl A a) T (a, refl A a) (x, p) (contrSingl A a x p) d
      where T (z : singl A a) : U = C (z.1) (z.2)

-- interval type
data I = i0 | i1 | path <i> [ (i=0) -> i0 , (i=1) -> i1 ]

-- n-Groupoid
data N = Z  | S (n: N)

n_grpd (A: U) (n: N): U = (a b: A) -> ((rec A a b) n) where
  rec (A: U) (a b: A): (k: N) -> U = split
    Z -> Path A a b
    S n -> n_grpd (Path A a b) n

isContr     (A: U): U = (x: A) * ((y: A) -> Path A x y)
isProp      (A: U): U = (x y: A) -> Path A x y
isProp      (A: U): U = n_grpd A Z
isSet       (A: U): U = n_grpd A (S Z)
isGroupoid  (A: U): U = n_grpd A (S (S Z))
isGrp2      (A: U): U = n_grpd A (S (S (S Z)))
isGrp3      (A: U): U = n_grpd A (S (S (S (S Z))))

PROP      : U = (X:U) * isProp X
SET       : U = (X:U) * isSet X
GROUPOID  : U = (X:U) * isGroupoid X
