module s2 where
import hopf

data bool = false | true
data nat = zero | succ (x: nat)
data either (A B: U) = inl (x:A) | inr (y:B)
data unit = tt
one: nat = succ zero
two: nat = succ one

data S1 = base | loop <i> [ (i=0) -> base, (i=1) -> base ]
data susp (A : U) = north | south | merid (a : A) <i> [ (i=0) -> north, (i=1) -> south ]
data sph = pt | surf <i j> [ (i=0) -> pt, (i=1) -> pt, (j=0) -> pt, (j=1) -> pt ]

loopS1 : Path S1 base base = <i> loop {S1} @ i
S2: U = susp S1

data SEL = first | second
S1MODEL: U = (positive: bool) -- split for "case" or "whole"
           * (A: U) * (base: A)
           * (B: U) * (loop: B)
           * (case: SEL -> either A B)
           * (whole: (X: A) * B) * unit

whole: (_: S1) * (Path S1 base base)
  = (base,loopS1)
selector: SEL -> either S1 (Path S1 base base)
  = split { first -> inl base ; second -> inr loopS1 }
instance: S1MODEL
  = (true,S1,base,Path S1 base base,loopS1,selector,whole,tt)

Square (A : U) (a0 a1 b0 b1 : A) (u : Path A a0 a1) (v : Path A b0 b1)
  (r0 : Path A a0 b0) (r1 : Path A a1 b1) : U
  = PathP (<i> (PathP (<j> A) (u @ i) (v @ i))) r0 r1

sqSurf (x: sph): Square sph x x x x (<i> x) (<i> x) (<i> x) (<i> x)
  = <i j> hcomp sph x [(i=0) -> <i> x, (i=1) -> <i> x,
                       (j=0) -> <i> x, (j=1) -> <i> x ]

loop2   : Path (Path sph pt pt) (<i>pt) (<i>pt) = sqSurf pt
loop3   : Path sph pt pt = loop2 @ 0
loopSph : Path (Path sph pt pt) (<i>pt) (<i>pt) = <i j> surf {sph} @ i @ j
loop4   : Path sph pt pt = loopSph @ 1
loopEq  : Path (Path (Path sph pt pt) (<i>pt) (<i>pt)) loop2 loopSph = undefined

