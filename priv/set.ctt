{- Set Theory:
   - Injectivity;
   Copyright (c) Groupoid Infinity, 2014-2018.

   see HoTT 3.1 Sets and n-types -}

module set where
import proto
import path
import prop
import pi
import sigma
import equiv

-- Contractible is a Prop

corSigProp (A:U) (B:A-> U) (pB : (x:A) -> isProp (B x)) (t u : Sigma A B) (p:Path A t.1 u.1) :
  isProp (PathP (<i>B (p@i)) t.2 u.2) = substInv U isProp T0 T1 rem rem1
 where P : Path U (B t.1) (B u.1) = <i>B (p@i)
       T0 : U = PathP P t.2 u.2
       T1 : U = Path (B u.1) (transport P t.2) u.2
       rem : Path U T0 T1 = pathSig0 A B t u p
       v2 : B u.1 = transport P t.2
       rem1 : isProp T1 = propSet (B u.1) (pB u.1) v2 u.2

setIsProp (A : U) : isProp (isSet A) =
 \(f g : isSet A) -> <i> \(a b :A) ->
   propIsProp (Path A a b) (f a b) (g a b) @ i

setUnit : isSet unit = propSet unit propUnit

inj0 (A B : U) (f : A -> B) (sA : isSet A) (sB : isSet B) : U
  = (a0 a1 : A) -> Path B (f a0) (f a1) -> Path A a0 a1

-- Second definition of injectivity, informally: for any b in B, there are
-- only one elment a in A such that f a is equal to b.
inj1 (A B : U) (f : A -> B) (sA : isSet A) (sB : isSet B) : U
  = (b : B) -> isProp ((a : A) * Path B (f a) b)

-- A map from the first to the second definition.
inj01 (A B : U) (f : A -> B) (sA : isSet A) (sB : isSet B) : inj0 A B f sA sB ->
    inj1 A B f sA sB
  = \ (i0 : inj0 A B f sA sB) (b : B) (c d : (a : A) * Path B (f a) b) -> let
    F (a : A) : U
      = Path B (f a) b
    pF (a : A) : isProp (F a)
      = sB (f a) b
    p : Path B (f c.1) (f d.1)
      = <i> comp (<j> B) (c.2 @ i) [ (i = 0) -> <j> f c.1
                                   , (i = 1) -> <j> d.2 @ -j ]
    q : Path A c.1 d.1
      = i0 c.1 d.1 p
  in
    lemSig A F pF c d q

-- A map from the second to the first definition.
inj10 (A B : U) (f : A -> B) (sA : isSet A) (sB : isSet B) : inj1 A B f sA sB ->
    inj0 A B f sA sB
  = \ (i1 : inj1 A B f sA sB) (a0 a1 : A) (p : Path B (f a0) (f a1)) -> let
    c : (a : A) * Path B (f a) (f a1)
      = (a0, p)
    d : (a : A) * Path B (f a) (f a1)
      = (a1, <i> f a1)
    q : Path ((a : A) * Path B (f a) (f a1)) c d
      = i1 (f a1) c d
    fst : ((a : A) * Path B (f a) (f a1)) -> A
      = \ (x : (a : A) * Path B (f a) (f a1)) -> x.1
  in
    <i> fst (q @ i)

-- A proof that the first definition of injectivity is a proposition.
prop_inj0 (A B : U) (f : A -> B) (sA : isSet A) (sB : isSet B)
  : isProp (inj0 A B f sA sB)
  = let
    c (a0 a1 : A) : isProp (Path B (f a0) (f a1) -> Path A a0 a1)
      = let
        P : Path B (f a0) (f a1) -> U
          = \ (_ : Path B (f a0) (f a1)) -> Path A a0 a1
        h : (x : Path B (f a0) (f a1)) -> isProp (P x)
          = \ (_ : Path B (f a0) (f a1)) -> sA a0 a1
      in
        propPi (Path B (f a0) (f a1)) P h
    d (a0 : A) : isProp ((a1 : A) -> Path B (f a0) (f a1) -> Path A a0 a1)
      = let
        P : A -> U
          = \ (a1 : A) -> ( Path B (f a0) (f a1) -> Path A a0 a1 )
        h : (a1 : A) -> isProp (P a1)
          = \ (a1 : A) -> c a0 a1
      in
        propPi A P h
    e : isProp (inj0 A B f sA sB)
      = let
        P : A -> U
          = \ (a0 : A) -> ( (a1 : A) -> Path B (f a0) (f a1) -> Path A a0 a1 )
        h : (a0 : A) -> isProp ( (a1 : A) -> Path B (f a0) (f a1) -> Path A a0 a1 )
          = \ (a0 : A) -> d a0
      in
        propPi A P h
  in
    e

-- A proof that the second definition of injectivity is a proposition.
prop_inj1 (A B : U) (f : A -> B) (sA : isSet A) (sB : isSet B) :
    isProp (inj1 A B f sA sB)
  = let
    P : B -> U
      = \ (b : B) -> (a : A) * Path B (f a) b
    Q : B -> U
      = \ (b : B) -> isProp (P b)
    h : (b : B) -> isProp (Q b)
      = \ (b : B) -> propIsProp (P b)
  in
    propPi B Q h

-- Inhabitance of PROP
hsubtypes  (X: U): U = X -> PROP
hrel       (X: U): U = X -> X -> PROP
funresprel  (A B: U) (f: A->B) (R: hrel A): U = (a a': A) (r: (R a a').1) -> Path B (f a) (f a')
funresprel2 (A B C: U) (f: A->B->C) (R0: hrel A) (R1: hrel B): U = (a a': A) (b b': B)->(R0 a a').1->(R1 b b').1 -> Path C (f a b) (f a' b')
ishinh_UU  (X: U): U = (P: PROP) -> ((X -> P.1) -> P.1)
propishinh (X: U): isProp (ishinh_UU X) = propPi PROP (\(P:PROP)->((X->P.1)->P.1)) (\(P:PROP)->propPi (X->P.1) (\(_: X->P.1)->P.1) (\(f: X->P.1)->P.2))
ishinh     (X: U): PROP = (ishinh_UU X,propishinh X)
hinhpr     (X: U): X -> (ishinh X).1 = \(x: X) (P: PROP) (f: X -> P.1) -> f x
exists     (A: U) (B: A -> U): PROP = ishinh ((x: A) * B x)
existspr   (A: U) (B: A -> U) (a: A) (b: B a): (exists A B).1 = hinhpr ((x : A) * B x) (a, b)
hProppair (X Y: PROP): PROP = (prod X.1 Y.1, propAnd X.1 Y.1 X.2 Y.2)
hrelpair (A B: U) (R0 : hrel A) (R1 : hrel B) (x y: prod A B): PROP = hProppair (R0 x.1 y.1) (R1 x.2 y.2)
hsubtypespair (A B: U) (H0: hsubtypes A) (H1: hsubtypes B) (x: prod A B): PROP = hProppair (H0 x.1) (H1 x.2)
hinhuniv   (X: U) (P: PROP) (f: X -> P.1) (inhX: (ishinh X).1): P.1 = inhX P f
existsel   (A: U) (B: A -> U) (P: PROP) (f: (x:A)->(B x)->P.1) (e: (exists A B).1): P.1
   = hinhuniv ((x: A)*B x) P (\(z:(x:A)*(B x))->f z.1 z.2) e
carrier    (X: U) (A: hsubtypes X) : U = (x : X) * (A x).1

iseqclass (X : U) (R : hrel X) (A : hsubtypes X) : U =
  prod (prod (ishinh (carrier X A)).1
                   ((x1 x2 : X) -> (R x1 x2).1 -> (A x1).1 -> (A x2).1))
          ((x1 x2 : X) -> (A x1).1 -> (A x2).1 -> (R x1 x2).1)
propiseqclass (X : U) (R : hrel X) (A : hsubtypes X) : isProp (iseqclass X R A) =
  propAnd (prod (ishinh (carrier X A)).1
                          ((x1 x2 : X) -> (R x1 x2).1 -> (A x1).1 -> (A x2).1))
                 ((x1 x2 : X) -> (A x1).1 -> (A x2).1 -> (R x1 x2).1)
                 (propAnd (ishinh (carrier X A)).1
                                 ((x1 x2 : X) -> (R x1 x2).1 -> (A x1).1 -> (A x2).1) p1 p2)
                 p3
  where
  p1 : isProp (ishinh (carrier X A)).1 = propishinh (carrier X A)

  -- This proof is quite cool, but it looks ugly...
  p2 (f g : (x1 x2 : X) -> (R x1 x2).1 -> (A x1).1 -> (A x2).1) :
   Path ((x1 x2 : X) -> (R x1 x2).1 -> (A x1).1 -> (A x2).1) f g =
    <i> \(x1 x2 : X) (h1 : (R x1 x2).1) (h2 : (A x1).1) ->
         (A x2).2 (f x1 x2 h1 h2) (g x1 x2 h1 h2) @ i

  p3 (f g : (x1 x2 : X) -> (A x1).1 -> (A x2).1 -> (R x1 x2).1) :
    Path ((x1 x2 : X) -> (A x1).1 -> (A x2).1 -> (R x1 x2).1) f g =
   <i> \(x1 x2 : X) (h1 : (A x1).1) (h2 : (A x2).1) ->
        (R x1 x2).2 (f x1 x2 h1 h2) (g x1 x2 h1 h2) @ i

