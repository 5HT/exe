module univ where
import retract
import equiv
import sigma
import path
import iso

-- Alt1 formulation of univalence. This is Corollary 10 of the
-- cubical type theory paper (the proof of theorem 9 is
-- inlined). The formalization is due to Fabian Ruch.
univalenceAlt (B : U) : isContr ((X : U) * equiv X B) =
 ((B,idEquiv B)
 ,\(w : (X : U) * equiv X B)
    -> <i> let GlueB : U = Glue B [(i=0) -> (B,idEquiv B), (i=1) -> w]
               unglueB (g : GlueB) : B = unglue g [(i=0) -> (B,idEquiv B),(i=1) -> w]
           in (GlueB
              ,unglueB
              ,\(b : B)
               -> let center : fiber GlueB B unglueB b
                             = (glue (comp (<j> B) b [(i=0) -> <j> b
                                                     ,(i=1) -> (w.2.2 b).1.2])
                                         [(i=0) -> b
                                         ,(i=1) -> (w.2.2 b).1.1]
                               ,fill (<j> B) b [(i=0) -> <j> b
                                               ,(i=1) -> (w.2.2 b).1.2])
                      contr (v : fiber GlueB B unglueB b)
                            : Path (fiber GlueB B unglueB b) center v
                            = <j> (glue (comp (<j> B) b [(i=0) -> <k> v.2 @ (j /\ k)
                                                        ,(i=1) -> ((w.2.2 b).2 v @ j).2
                                                        ,(j=0) -> fill (<j> B) b [(i=0) -> <j> b
                                                                                     ,(i=1) -> (w.2.2 b).1.2]
                                                        ,(j=1) -> v.2])
                                            [(i=0) -> v.2 @ j
                                            ,(i=1) -> ((w.2.2 b).2 v @ j).1]
                                  ,fill (<j> B) b [(i=0) -> <l> v.2 @ (j /\ l)
                                                  ,(i=1) -> ((w.2.2 b).2 v @ j).2
                                                  ,(j=0) -> fill (<j> B) b [(i=0) -> <j> b
                                                                           ,(i=1) -> (w.2.2 b).1.2]
                                                  ,(j=1) -> v.2])
                  in (center,contr)))

contrSingl' (A : U) (a b : A) (p : Path A a b) :
  Path ((x:A) * Path A x b) (b,refl A b) (a,p) = <i> (p @ -i,<j> p @ -i\/j)

lemSinglContr' (A:U) (a:A) : isContr ((x:A) * Path A x a) =
 ((a,refl A a),\ (z:(x:A) * Path A x a) -> contrSingl' A z.1 a z.2)


-- A version univalence. This is Corollary 11 of the cubical type
-- theory paper.
thmUniv (t: (A X: U) -> Path U X A -> equiv X A) (A : U)
      : (X: U) -> isEquiv (Path U X A) (equiv X A) (t A X)
      = equivFunFib U (\(X : U) -> Path U X A) (\(X : U) -> equiv X A) (t A) (lemSinglContr' U A) (univalenceAlt A)

transEquiv' (A X : U) (p : Path U X A)
          : equiv X A
          = subst U (\(Y : U) -> equiv Y A) A X (<i> p @ -i) (idEquiv A)

-- The univalence axiom
univalence (A X : U) : isEquiv (Path U X A) (equiv X A) (transEquiv' A X)
  = thmUniv transEquiv' A X

-- The standard formulation of univalence whose normal can be computed:
corrUniv (A B : U) : Path U (Path U A B) (equiv A B)
  = equivPath (Path U A B) (equiv A B) (transEquiv' B A) (univalence B A)

corrUniv' (A B : U) : equiv (Path U A B) (equiv A B)
  = (transEquiv' B A,univalence B A)

-- Elimination principle for equivalences and iso

contrSinglEquiv (A B : U) (f : equiv A B) :
  Path ((X : U) * equiv X B) (B,idEquiv B) (A,f) = rem
  where
  rem1 : isProp ((X : U) * equiv X B) = isContrProp ((X : U) * equiv X B) (univalenceAlt B)
  rem : Path ((X : U) * equiv X B) (B,idEquiv B) (A,f) = rem1 (B,idEquiv B) (A,f)

elimEquiv (B : U) (P : (A : U) -> (A -> B) -> U) (d : P B (idfun B))
            (A : U) (f : equiv A B) : P A f.1 = rem
  where
  T (z : (X : U) * equiv X B) : U = P z.1 z.2.1
  rem1 : Path ((X : U) * equiv X B) (B,idEquiv B) (A,f) = contrSinglEquiv A B f
  rem : P A f.1 = subst ((X : U) * equiv X B) T (B,idEquiv B) (A,f) rem1 d

elimIso (B : U) (Q : (A : U) -> (A -> B) -> (B -> A) -> U)
        (h1 : Q B (idfun B) (idfun B)) (A : U) (f : A -> B) : (g : B -> A) ->
        section A B f g -> retract A B f g -> Q A f g = rem1 A f
 where
   P (A : U) (f : A -> B) : U = (g : B -> A) -> section A B f g -> retract A B f g -> Q A f g

   rem : P B (idfun B) = \(g : B -> B) (sg : section B B (idfun B) g) (rg : retract B B (idfun B) g) ->
     substInv (B -> B) (Q B (idfun B)) g (idfun B) (<i> \(b : B) -> (sg b) @ i) h1

   rem1 (A : U) (f : A -> B) : P A f = \(g : B -> A) (sg : section A B f g) (rg : retract A B f g) -> 
          elimEquiv B P rem A (f,isoToEquiv A B f g sg rg) g sg rg

elimIsIso (A : U) (Q : (B : U) -> (A -> B) -> (B -> A) -> U)
         (d : Q A (idfun A) (idfun A)) (B : U) (f : A -> B) (g : B -> A)
         (sg : section A B f g) (rg : retract A B f g) : Q B f g =
  elimIso A (\(B : U) (f : B -> A) (g : A -> B) -> Q B g f) d B g f rg sg

---------------
ua (A B : U) (e : equiv A B) : Path U A B
  = <i> Glue B [ (i = 0) -> (A,e), (i = 1) -> (B,idEquiv B) ]

uabeta (A B : U) (e : equiv A B) : Path (A -> B) (trans A B (ua A B e)) e.1
  = <i> \(a : A) -> fill (<_> B) (fill (<_> B) (e.1 a) [] @ -i) [] @ -i

uabetaTransEquiv (A B : U) (e : equiv A B) : Path (A -> B) (transEquiv A B (ua A B e)).1 e.1
  = <i> \(a : A) -> (uabeta A B e @ i) (fill (<_> A) a [] @ -i)

uaret (A B : U) : retract (equiv A B) (Path U A B) (ua A B) (transEquiv A B)
  = \(e : equiv A B) -> equivLemma A B (transEquiv A B (ua A B e)) e (uabetaTransEquiv A B e)

f1 (A : U) (p : (B : U) * equiv A B) : ((B : U) * Path U A B) = (p.1,ua A p.1 p.2)
f2 (A : U) (p : (B : U) * Path U A B) : ((B : U) * equiv A B) = (p.1,transEquiv A p.1 p.2)

uaretsig (A : U) : retract ((B : U) * equiv A B) ((B : U) * Path U A B) (f1 A) (f2 A)
  = \(p : (B : U) * equiv A B) -> <i> (p.1,uaret A p.1 p.2 @ i)

univalenceAlt2 (A : U) : isContr ((B : U) * equiv A B)
  = retIsContr ((B : U) * equiv A B) ((B : U) * Path U A B) (f1 A) (f2 A) (uaretsig A) (isContrPath A)

